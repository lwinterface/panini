{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"0.7.2/","title":"Panini Docks","text":"<p>\ud83d\udc4b</p> <p>Hey there!</p> <p>Welcome to Panini's explanatory documentation! Here you can become familiar with the concept, learn how to setup a working environment, and take your first steps towards building with it.</p> <p>Panini is a python microframework based on the nats.py library. Its goal is to offer developers an easy way to create NATS microservices with a lower barrier of entry. It provides a specific template for creating microservices, similarly to FastAPI, Aiohttp, or Flask. Like all of the above frameworks, Panini has its design limits and edge cases. In the event that you become restricted by Panini's capabilities, we recommend switching to nats.py.</p> <p>Panini was inspired by Faust project.</p> <p>What are microservices?</p> <p>Microservices are a type of software architecture that breaks up the features of an application into smaller, task-specific\u00a0functions to make the app more resilient and scalable. More info about it here: https://microservices.io</p> <p>What can Panini do for me?</p> <p>Panini allows you to create microservices that use NATS to communicate with each other and extend the microservice by adding an HTTP server (aiohttp) to it if necessary.</p> <p>Compatibility with libraries</p> <p>Panini works well with various libraries used with FastAPI, Aiohttp, or Flask.</p> <p>Can I scale it?</p> <p>Yes, you can scale out your microservices horizontally. There are 2 strategies for distributing traffic between microservices:</p> <ul> <li>Parallel processing: Each microservice processes all messages</li> <li>Balancing: Messages are placed in a common queue and distributed among a group of microservices</li> </ul> <p>Monitoring</p> <p>Panini has a Grafana dashboard for performance monitoring; the code is here. Also, we are planning to add the ability to use Opentracing soon.</p> <p>Do you support JetStream?</p> <p>Not at the moment.</p> <p>How to start?</p> <p>We recommend getting familiar with Panini in the following order:</p> <ul> <li>Understand what NATS is about</li> <li>Install NATS and Panini</li> <li>Complete Quickstart</li> <li>Understand Panini interface and datatypes</li> <li>Explore validation and middlewares</li> <li>Try to create a Panini microservice with an HTTP server</li> <li>Test and debug</li> <li>Deploy to server</li> <li>Write your own issue and PR to make Panini better \ud83d\ude42</li> </ul>"},{"location":"0.7.2/Application_monitoring/","title":"\ud83d\udc40 Application Monitoring","text":""},{"location":"0.7.2/Application_monitoring/#overview","title":"Overview","text":"<p>With microservices, it can be challenging to get a comprehensive view of what is occurring within your system. We decided to implement the built-in possibility to monitor performance in order to reveal problems or bugs in the system faster and simpler.</p> <p>We are using:</p> <ul> <li>Prometheus time-series database &amp; monitoring solution.</li> <li>Grafana for user-friendly dashboards.</li> <li>Panini built-in middleware PrometheusMonitoringMiddleware</li> </ul> <p>The main idea of PrometheusMonitoringMiddleware is to collect important metrics, such as:</p> <ul> <li>Message rate by subject</li> <li>Request status (success or failure)</li> <li>Request latency</li> </ul> <p>After collecting, it periodically sends these metrics to Prometheus Gateway that reflected directly in your Grafana dashboard*.*</p>"},{"location":"0.7.2/Application_monitoring/#initializing-the-monitoring","title":"Initializing the monitoring","text":"<p>Suppose that we already have Prometheus &amp; Grafana up and running.</p> <p>After that, we need to add PrometheusMonitoringMiddleware to the app:</p> <pre><code>from panini.middleware.prometheus_middleware import PrometheusMonitoringMiddleware\n\napp.add_middleware(PrometheusMonitoringMiddleware)\n# you could also specify some custom parameters (see details in middleware constructor):\n# app.add_middleware(PrometheusMonitoringMiddleware, PROMETHEUS_GATEWAY, frequency=30)\n</code></pre> <p>PrometheusMonitoringMiddleware parameters:</p> <ul> <li>pushgateway_url: str = \"localhost:9091\" - url to Prometheus PushGateway</li> <li>app = None - panini App</li> </ul> <p>After this, application activity will be stored in Prometheus and demonstrated in the Grafana dashboard.</p>"},{"location":"0.7.2/Application_monitoring/#using-grafana-prometheus","title":"Using Grafana &amp; Prometheus","text":"<p>Below is our dashboard that you can get here:</p> <p></p> <p>You can use our template or dig into Grafana for a more custom approach.</p> <p>How to set up Grafana &amp; Prometheus"},{"location":"0.7.2/AsyncTesting/","title":"Async Testing","text":"<p>A more advanced way to proceed with testing the Panini application. Please, proceed with simple \"Panini Testing\" for a better experience.</p> <p>Ability to run async tests is required for using <code>AsyncTestClient</code> (were tested only using pytest-async )</p>"},{"location":"0.7.2/AsyncTesting/#advantages-vs-testclient","title":"Advantages vs TestClient","text":"<ul> <li>Supports <code>&gt;</code> and <code>*</code> in subjects;</li> <li>Advanced usage of <code>await client.wait()</code>;</li> <li>Similar interface as with <code>panini.nats_client</code>;</li> <li>Separate timeout for each <code>publish</code>, <code>request</code>, <code>wait</code>;</li> <li>Additional <code>count_subject_calls</code> function.</li> </ul>"},{"location":"0.7.2/AsyncTesting/#using-asynctestclient","title":"Using AsyncTestClient","text":"<p>The process of working with <code>AsyncTestClient</code> is similar to simple <code>TestClient</code></p> <p>Import <code>AsyncTestClient</code>.</p> <p>Create an <code>AsyncTestClient</code> object using pytest.fixture (with async support) with passing to it the function that <code>runs panini</code>.</p> <p><code>AsyncTestClient</code> object <code>.start()</code> will start the panini app for testing.</p> <p>Create <code>functions</code> with a name that starts with <code>test_</code> (this is standard <code>pytest</code> conventions).</p> <p>Use <code>@pytest.mark.asyncio</code> for async support - pytest-asyncio feature.</p> <p>Use the <code>AsyncTestClient</code> object for nats communication the same way as you do with <code>panini</code> (but with some limitations)</p> <p>(The panini uses nats-io asynchronous NATS client for testing)</p> <p>Write simple <code>assert</code> statements with the standard Python expressions that you need to check (<code>pytest</code> standard).</p> <pre><code>import pytest\nfrom panini import app as panini_app\nfrom panini.async_test_client import AsyncTestClient\n\ndef run_panini():\n    app = panini_app.App(\n        service_name=\"test\",\n        host=\"127.0.0.1\",\n        port=4222\n    )\n\n    @app.listen(\"main.subject\")\n    async def main_subject(msg):\n        return {\"message\": \"Hello World!\"}\n\n    app.start()\n\n@pytest.fixture\nasync def client():\n    client = await AsyncTestClient(run_panini).start()\n    yield client\n    await client.stop()\n\n@pytest.mark.asyncio\nasync def test_main_subject(client):\n    response = await client.request(\"main.subject\", {})\n    assert response[\"message\"] == \"Hello World!\"\n</code></pre> <p>Notice that the testing functions are normal <code>async def</code>, not common <code>def</code>. And calls to the client are also using <code>await</code>. This is allowed because of <code>pytest-asyncio</code>.</p> <p>Notice that panini AsyncTestClient will run the panini app in a <code>different process</code>.  The Windows and Mac platforms have limitations for transferring objects to different processes. So we have to use <code>run_panini</code> function that will implement or import our app, and we must use <code>fixtures</code> to set up AsyncTestClient.</p>"},{"location":"0.7.2/AsyncTesting/#examples-use-cases-in-code","title":"Examples &amp; use cases in code","text":"<p>Usage of <code>client.count_subject_calls()</code> example:</p> <p><code>main.py</code></p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.listen(\"choose.table\")\nasync def choose_table(msg):\n    for table_id in range(10):\n        response = await app.request(\"check.table.is.free\", {\"table_id\": table_id})\n        if response[\"is_free\"] is True:\n            await app.publish(f\"reserve.table.{table_id}\", {})\n            return {\"success\": True, \"table_id\": table_id}\n\n    return {\"success\": False}\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p><code>test_main.py</code></p> <pre><code>import pytest\nfrom panini.async_test_client import AsyncTestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\n@pytest.fixture\nasync def client():\n    client = AsyncTestClient(run_panini)\n\n    @client.listen(\"check.table.is.free\")\n    def check_table_is_free(msg):\n        if msg.data[\"table_id\"] == 4:\n            return {\"is_free\": True}\n        return {\"is_free\": False}\n\n    @client.listen(\"reserve.table.*\")\n    def reserve_table(msg):\n        pass\n\n    await client.start()  # use after @client.listen\n    yield client\n    await client.stop()\n\n@pytest.mark.asyncio\nasync def test_choose_table(client: AsyncTestClient):\n    response = await client.request(\"choose.table\", {})\n    assert response[\"success\"] is True\n    assert response[\"table_id\"] == 4\n    assert client.count_subject_calls(\"check.table.is.free\") == 5\n    assert client.count_subject_calls(\"reserve.table.*\") == 1\n</code></pre> <p>Usage of <code>client.wait()</code>:</p> <p><code>main.py</code></p> <pre><code>import time\n\nfrom panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.task()\nasync def publish_data():\n    for _ in range(5):\n        await app.publish(\"data.1\", {\"data\": \"data1\"})\n        time.sleep(0.05)\n\n    for _ in range(5):\n        await app.publish(\"data.2\", {\"data\": \"data2\"})\n        time.sleep(0.05)\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p><code>test_main.py</code></p> <pre><code>import pytesawait client.wait(10, timeout=0.5)t\nfrom panini.async_test_client import AsyncTestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\ndata = []\n\n@pytest.fixture\nasync def client():\n    client = AsyncTestClient(run_panini)\n\n    @client.listen(\"data.*\")\n    def save_data(msg):\n        data.append(msg.data)\n\n    await client.start()\n    yield client\n    data.clear()\n    await client.stop()\n\n@pytest.mark.asyncio\nasync def test_task_publish_data_1(client: AsyncTestClient):\n    await client.wait(10, timeout=0.5)\n    assert len(data) == 10\n\n@pytest.mark.asyncio\nasync def test_task_publish_data_2(client: AsyncTestClient):\n    await client.wait(10, subject=\"data.*\")\n    assert len(data) == 10\n\n@pytest.mark.asyncio\nasync def test_task_publish_data_3(client: AsyncTestClient):\n    await client.wait(subjects={\n        \"data.1\": 5,\n        \"data.2\": 5,\n    })\n    assert len(data) == 10\n</code></pre> <p>All these 3 methods are suited to test this <code>main.py</code>, but the last one is the most concrete.</p>"},{"location":"0.7.2/Authentication/","title":"\ud83d\udd11 Authentication","text":"<p>Authentication is essential for any system, especially microservice architectures. Modern design approaches tend to isolate and encapsulate microservices. For the NATS world, this becomes especially critical with the release of one of the key features of NATS 2.0 - decentralized security. This feature allows creating access groups at NATS client level and at subject level. In other words, it \"containerizes\" a network, which opens up new possibilities for engineers. </p> <p>NATS offers several authentication strategies, we suggest you explore them here: https://docs.nats.io/developing-with-nats/security</p> <p>Panini does not interact with the authentication process. In fact, it just gives the interface of nats.py to establish a connection with authentication. NATS supports user-password, token, JWT, TLS, and NKeys authentication.</p> <p>Let's make an example with User-password. First, we need to run NATS broker with user-password access:</p> <pre><code>nats-server --user john --pass johnpassword\n</code></pre> <p>Then let's write a microservice that connects to NATS but without the user and the password:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"some_microservice\",\n    host=\"127.0.0.1\",\n    port=4222,\n)\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>Let's save it to a file named app.py and run it:</p> <pre><code>&gt; python3 app.py\n2021-11-04 14:58:07,163 nats.aio.client ERROR    nats: encountered error\nTraceback (most recent call last):\n  File \"*/*/*\", line 318, in connect\n    await self._process_connect_init()\n  File \"*/*/*\", line 1673, in _process_connect_init\n    raise NatsError(\"nats: \" + err_msg.rstrip('\\r\\n'))\nnats.aio.errors.NatsError: nats: 'Authorization Violation'\n</code></pre> <p>As you can see, an 'Authorization Violation' raised. There is no way to establish a connection with the NATS broker without credentials. Let's add the username and the password to our app:</p> <pre><code>from panini import app as panini_app\n\nauth = {\n    \"user\": \"john\",\n    \"password\": \"jpassword\"\n}\n\napp = panini_app.App(\n    service_name=\"some_microservice\",\n    host=\"127.0.0.1\",\n    port=4222,\n    auth=auth\n)\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>Let's run it again:</p> <pre><code>&gt; python3 app.py\n======================================================================================\nPanini service connected to NATS..\nid: 3\nname: some_microservice__non_docker_env_270377__75017\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n</code></pre> <p>It seems we have connected to the NATS broker! </p> <p>You can check out more on authentication in nats.py specs or NATS docs.</p>"},{"location":"0.7.2/Balancer/","title":"\ud83e\udd39 Balancer","text":"<p>Sometimes there can be too much traffic and it is necessary to scale services horizontally, i. e. create several instances of a microservice in order to distribute the incoming traffic between them. This section will describe how to work with this issue.</p> <p>Let's say you created two instances of a microservice that are subscribed on the subject <code>some.data.stream.one</code>, then both will receive all messages. It's the default behaviour of NATS microservices. NATS allows for easily uniting instances of a microservice to a group where incoming traffic will be equally allocated among instances automatically:</p> <p></p> <p>How to program traffic distribution with Panini:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"async_publish\",\n    host=\"127.0.0.1\",\n    port=4222,\n        allocation_queue_group='unit1'\n)\n</code></pre> <p>When the class App is initialized, it takes <code>allocation_queue_group</code> as an additional argument. Then all microservices in this group <code>unit1</code> will distribute the incoming traffic among the group members.</p> <p>That's it. You only need to specify the group when creating a Panini app.</p>"},{"location":"0.7.2/Changelog/","title":"Changelog","text":""},{"location":"0.7.2/Changelog/#v072-2022-02-14","title":"v0.7.2 (2022-02-14)","text":"<ul> <li>Fixed reconnection problem</li> </ul>"},{"location":"0.7.2/Changelog/#v070-2022-02-14","title":"v0.7.0 (2022-02-14)","text":"<ul> <li>Support NATS 2.0\ud83c\udf89. Now the panini stands on shoulders of nats-py v2.0.0</li> <li>Support Python 3.10</li> <li>Introducing on_start_task</li> <li>Introducing minimal JetStream support Since Panini switched from asyncio-nats-client to nats-py, it has become possible to support one of the most important features of NATS 2.0 - JetStream. Panini v0.7.0 does not implement an interface to JetStream at the framework level. Instead, it is suggested to use directly nats-py.</li> </ul>"},{"location":"0.7.2/Changelog/#v062-2021-11-11","title":"v0.6.2 (2021-11-11)","text":"<ul> <li>Fixed bug: tasks doesn't works with HTTP server</li> <li>Fixed package incompatibility</li> </ul>"},{"location":"0.7.2/Changelog/#v062-2021-11-11_1","title":"v0.6.2 (2021-11-11)","text":"<ul> <li>Fixed bug: tasks doesn't works with HTTP server</li> <li>Fixed package incompatibility</li> </ul>"},{"location":"0.7.2/Changelog/#v060-2021-11-04","title":"v0.6.0 (2021-11-04)","text":"<ul> <li>Global refactoring</li> <li>Added new interface for pereodic tasks: <code>@app.task(interval=1)</code></li> <li>Changed <code>listen_subject_only_if_include</code> param in App to function <code>app.add_filters(include, exclude)</code></li> <li>Added ability to use all authorization methods from nats.py</li> <li>Added ability to establish connection to multiple NATS brokers</li> <li>Added start message when starting in terminal</li> </ul>"},{"location":"0.7.2/Changelog/#v052-2021-08-17","title":"v0.5.2 (2021-08-17)","text":"<ul> <li>Added ability to use any parameters for aiohttp including ssl_context(for HTTPS)</li> </ul>"},{"location":"0.7.2/Changelog/#v050-2021-07-21","title":"v0.5.0 (2021-07-21)","text":"<ul> <li>Implemented AsyncTestClient for better testing experience</li> <li>Added listen_subject_only_if_exclude parameter for excluding unnecessary subjects</li> </ul>"},{"location":"0.7.2/Changelog/#v040-2021-07-09","title":"v0.4.0 (2021-07-09)","text":"<ul> <li>Fixed silent error if response type is list</li> <li>Fixed TestClient</li> <li>Added non-blocking request support for bytes messages</li> <li>Added automatically generated changelog</li> <li>Added pending_bytes_limit parameter to panini App for nats_client</li> <li>Added is_async parameter to subscribe_new_subject for nats_client</li> <li>Added data types for dynamic subscription</li> <li>Added test for long requests</li> </ul>"},{"location":"0.7.2/Changelog/#v031-2021-05-25","title":"v0.3.1 (2021-05-25)","text":"<ul> <li>Fixed bug with no hinting for publish &amp; request functions</li> <li>Removed 'app_strategy' parameter</li> <li>Removed old 'aio' interface for nats_client &amp; managers</li> <li>Added auto unsubscribe to test_client waiting for panini to start</li> <li>Change ci test flow, add test on python v3.9-major fixes in TestClient, changes in client.wait() function</li> <li>Added non-blocking request support for bytes messages</li> </ul>"},{"location":"0.7.2/Changelog/#v030-2021-04-27","title":"v0.3.0 (2021-04-27)","text":"<ul> <li>removed sync app connection strategy</li> <li>removed redis dependency</li> <li>minor fix</li> </ul>"},{"location":"0.7.2/Changelog/#v023-2021-04-06","title":"v0.2.3 (2021-04-06)","text":"<ul> <li>Added CI/CD checks</li> <li>Moved from json to ujson</li> <li>Fixed logging bugs</li> <li>Fixed bug with emulator for windows</li> <li>Many minor bugs</li> </ul>"},{"location":"0.7.2/Changelog/#v022-2021-03-24","title":"v0.2.2 (2021-03-24)","text":"<ul> <li>Added Emulator middlewares: ReaderEmulatorMiddleware &amp; WriterEmulatorMiddleware</li> <li>Fixed Test client</li> <li>Minor fix: grafana dashboard default rate size changed from 1m to 15m PrometheusMonitoringMiddleware(ex ListenPerformancePrometheusTracerMiddleware)</li> </ul>"},{"location":"0.7.2/Changelog/#v020-2021-03-12","title":"v0.2.0 (2021-03-12)","text":"<ul> <li>Msg object instead of arguments subject and message in listener's callbacks</li> <li>Addition datatypes supported: bytes, str</li> <li>Added publish/request from another thread</li> <li>Added http-like middlewares</li> <li>Added default middleware that calculates processing time for incoming messages and sends it to pushgateway(prometheus)</li> <li>Added default middleware that sends alert message to some topic if service for NatsTimeoutError</li> <li>Changed default console logging level: WARNING -&gt; INFO</li> <li>Added new examples</li> </ul>"},{"location":"0.7.2/Data_Validation/","title":"\ud83d\udc6e\u200d\u2642\ufe0f Incoming data validation","text":"<p>When many microservices communicate with each other, an essential consideration for reliability is ensuring that NATS client properly validates incoming messages. Engineers want to make sure that any data that enters an application is valid and secure.</p> <p>Panini allows for checking all fields and data types of values for incoming JSON messages. Validator is very similar to Serializer in Django or Dataclasses. </p> <p>Example of validator:</p> <pre><code>class CoctailValidator(Validator):\n    id_ = Field(type=int)\n    name = Field(type=str)\n    price = Field(type=float)\n    ingredients = Field(type=dict)\n    history_of_orders = Field(type=list)\n</code></pre> <p>Validator can accept JSON data types or another validator if you need to validate data of a nested dictionary. </p> <p>Let's say we want to send a message by <code>microservice_1</code> ten times per second, the message:</p> <pre><code>{\n    \"key1\": \"value1\",\n    \"key2\": 2,\n    \"key3\": 3.02444441234,\n    \"key4\": [1, 2, 3, 4],\n    \"key5\": {\"1\": 1, \"2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key6\": {\"subkey1\": \"1\", \"subkey2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key7\": None,\n}\n</code></pre> <p>Then receive it by <code>microservice_2</code> but validate that all message fields and value types are correct. </p> <p><code>microservice_1</code>:</p> <pre><code>import json\nfrom panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='microservice_1',\n        host='127.0.0.1',\n        port=4222,\n)\n\nmessage = {\n    \"key1\": \"value1\",\n    \"key2\": 2,\n    \"key3\": 3.024444412342342342,\n    \"key4\": [1, 2, 3, 4],\n    \"key5\": {\"1\": 1, \"2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key6\": {\"subkey1\": \"1\", \"subkey2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key7\": None,\n}\n\n@app.task(interval=1)\nasync def publish_periodically():\n    for _ in range(10):\n        await app.publish(\n            subject=\"some.publish.subject\", message=message)\n        )\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p><code>microservice_2</code>:</p> <pre><code>import json\nfrom panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='microservice_2',\n        host='127.0.0.1',\n        port=4222,\n)\n\nclass SubTestValidator(Validator):\n    subkey1 = Field(type=str)\n    subkey2 = Field(type=int)\n\nclass TestValidator(Validator):\n    key1 = Field(type=str)\n    key2 = Field(type=int)\n    key3 = Field(type=float)\n    key4 = Field(type=list)\n    key5 = Field(type=dict)\n    key6 = Field(type=SubTestValidator)\n    key7 = Field(type=int, null=True)\n    key8 = Field(type=int, null=True, default=None)\n\n@app.listen(\"some.publish.subject\", validator=TestValidator)\nasync def requests_listener(msg):\n    log.info(f\"got message {msg.data}\")\n    await asyncio.sleep(1)\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>The validator model has to inherit Validator class. Acceptable python datatypes: </p> <ul> <li>str</li> <li>int</li> <li>float</li> <li>list</li> <li>dict</li> <li>bool</li> <li>None</li> <li>another validation model(SubTestValidator in the example)</li> </ul> <p>Each field optionally allows: </p> <ul> <li>add default key/value if they are absent in incoming message</li> <li>allows None(null) type</li> <li> <p>allows many nested objects in list, for example message:</p> <pre><code>{\n    \"key1\": [\n               {\"subkey1\": \"asdf1\", \"subkey2\": 342},\n               {\"subkey1\": \"sdf1\", \"subkey2\": 2},\n               {\"subkey1\": \"sdfsd1\", \"subkey2\": 2}\n            ]\n}\n</code></pre> <p>Validators:</p> <pre><code>class SubTestValidator(Validator):\n    subkey1 = Field(type=str)\n    subkey2 = Field(type=int)\n\nclass TestValidator(Validator):\n    key1 = Field(type=SubTestValidator, many=True) \n</code></pre> </li> </ul> <p>If an incoming message doesn't pass validation, Panini will raise <code>ValidationError</code>.</p> <p>We consider the current data validation system as underdeveloped. If you feel a lack of features, you can always consider external solutions for this:</p> <ul> <li>Dataclasses</li> <li>Cerberus</li> <li>Colander</li> <li>Jsonschema</li> </ul>"},{"location":"0.7.2/Datatypes/","title":"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66 Datatypes","text":""},{"location":"0.7.2/Datatypes/#basics","title":"Basics","text":"<p>Every project using a microservice architecture is unique and has different requirements for the message format of communication between microservices. For example, for systems in the e-commerce or fintech industry, JSON format might be appropriate, but if you need to make an audio stream, then you may prefer to work with raw bytes. Panini works with 3 data types of messages:</p> <ul> <li>JSON - default datatype</li> <li>Bytes</li> <li>String</li> </ul> <p>To set a specific datatype, you need to set it as argument <code>data_type</code> when sending messages:</p> <pre><code>await app.publish(\n          subject=\"some.data.in.bytes\",\n          message=b'23oesj2o4jrs93oijr9s3oijr02zoje01p92ek012sx01p2ke01pjz',\n          data_type=bytes,\n      )\n</code></pre> <p>or listening for messages:</p> <pre><code>@app.listen(\"some.data.in.bytes\", data_type=bytes)\nasync def receive_bytes(msg):\n    log.info(f\"got subject {msg.subject}\")\n    log.info(f\"got message {msg.data}\")\n</code></pre> <p>If an incoming message to a microservice requires an answer, Panini expects the output type to be the same as the input type. For example:</p> <pre><code>@app.listen(\"subject.for.request.in.bytes\", data_type=bytes)\nasync def receive_bytes(msg):\n    data = msg.data\n      result = some_process_of_request(data)\n    validate_result_is_bytes(result)  # the result should be returned as bytes\n    return result\n</code></pre> <p>The result should be returned as bytes, otherwise, Panini will raise an exception.</p>"},{"location":"0.7.2/Datatypes/#one-more-example","title":"One more example","text":"<p>JSON type transforms to python's dict inside an endpoint's function. In this case, all the elements of your dict should be capable of jsonfying in order to send a response.</p> <p>Let's take a look at an example that includes a task that sends a message and 3 listeners that receive this message as different datatypes:</p> <pre><code>import json\nfrom panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='quickstart-app',\n        host='127.0.0.1',\n        port=4222,\n)\n\nmessage = {\n    \"key4\": \"value1\",\n    \"key7\": 2,\n    \"key3\": 3.024444412342342342,\n    \"key1\": [1, 2, 3, 4],\n    \"key6\": {\"1\": 1, \"2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key5\": {\"subkey1\": \"1\", \"subkey2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key2\": None,\n}\n\n@app.task(interval=1)\nasync def publish_string():\n    some_string = json.dumps(message, sort_keys=True)\n    for _ in range(10):\n        await app.publish(\n            subject=\"some.publish.subject\", \n            message=some_string, \n            data_type=str,\n        )\n\n@app.listen(\"some.publish.subject\")\nasync def receive_dict(msg):\n    log.info(f\"got subject {msg.subject}\")\n    log.info(f\"got message {msg.data} type: {type(msg.data)}\")\n\n@app.listen(\"some.publish.subject\", data_type=str)\nasync def receive_string(msg):\n    log.info(f\"got subject {msg.subject}\")\n    log.info(f\"got message {msg.data} type: {type(msg.data)}\")\n\n@app.listen(\"some.publish.subject\", data_type=bytes)\nasync def receive_bytes(msg):\n    log.info(f\"got subject {msg.subject}\")\n    log.info(f\"got message {msg.data} type: {type(msg.data)}\")\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>What is going on here:</p> <ol> <li>The message template is a dict that can be transformed into JSON</li> <li><code>@app.task</code> publishes data in string format to subject <code>\"some.publish.subject\"</code>(jsonifyed data is a string)</li> <li>The first <code>@app.listen</code> receives this data as default datatype - transforms it to dict</li> <li>The second <code>@app.listen</code> receives the same data as a string</li> <li>The third <code>@app.listen</code> receives the same data as bytes</li> </ol> <p>\ud83d\udca1</p><p> All these datatypes are just representations at the Panini level. Eventually, Panini transforms data into bytes before sending it to NATS for any datatype. When another microservice receives this message, it also receives bytes then transforms it into the requested datatype in the endpoint function.</p> <p>String type is string only inside the endpoint's function. Eventually, a microservice sends bytes anyway.</p>"},{"location":"0.7.2/Deployment/","title":"\ud83c\udfd7\ufe0f Deployment","text":"<p>\ud83d\udee0</p><p> This page is under construction</p>"},{"location":"0.7.2/Distributed_tracing/","title":"\ud83d\udd0d Distributed tracing","text":"<p>The tracing feature will be released as soon as the nats.py on which Panini is based releases the ability to use headers in NATS messages. Panini will provide tools for Opentracing:</p> <ul> <li>middleware for automatic tracing</li> <li>an interface to manage tracing manually.</li> </ul> <p>\ud83d\udee0</p><p> This page is under construction</p>"},{"location":"0.7.2/Emulator/","title":"\ud83d\udd70\ufe0f Emulator - \"time machine\" debug","text":"<p>This feature is currently being tested. The main idea is very simple: If the service breaks down, the developer can \u201croll back time\u201d by N milliseconds and reproduce all messages that come to the microservice in debug mode.</p> <p>\ud83d\udee0</p><p> This page is under construction</p>"},{"location":"0.7.2/Examples/","title":"Examples","text":"<p>Simple examples</p> <p>Panini+PostgreSQL</p> <p>1 million requests</p>"},{"location":"0.7.2/HTTP_server/","title":"\ud83e\udd86 HTTP server","text":"<p>In some cases a NATS network is not enough for microservice's requirements and engineers may need an HTTP web server in one microservice with NATS. For an HTTP server, Panini uses Aiohttp. It might be useful if you need to handle HTTP requests from a frontend or other microservices to create a gateway between HTTP and NATS spaces.</p> <p>In order to run a HTTP server you have to call <code>app.setup_web_server</code> with host, port, and other parameters that you want to pass to Aiohttp, for example, <code>ssl_context</code> , <code>shutdown_timeout</code> or <code>access_log</code>.</p> <p>Panini microservice with HTTP endpoint might look like this:</p> <pre><code>from aiohttp import web\nfrom panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='nats-microservice-that-also-http',\n        host='127.0.0.1',\n        port=4222,\n)\napp.setup_web_server(port=5000)\n\n# NATS listeners &amp; tasks\n\n@app.http.get(\"/test\")\nasync def web_endpoint_listener(request):\n\"\"\"\n    Single HTTP endpoint\n    \"\"\"\n    return web.Response(text=\"Hello, HTTP world\")\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>As you can see it uses <code>@app.http.get</code> for HTTP.  Panini uses Aiohttp under the hood, in other words <code>@app.http</code> is <code>routes</code> from Aiohttp. Let's take a look at an example with some Aiohttp code(without Panini): </p> <pre><code>routes = web.RouteTableDef()\n\n@routes.get('/get')\nasync def handle_get(request):\n    ...\n\n@routes.post('/post')\nasync def handle_post(request):\n    ...\n\napp.router.add_routes(routes)\n</code></pre> <p>Whats going on here:</p> <ol> <li>Getting <code>routes</code> object in the first line of code</li> <li><code>@routes.get('/get')</code> bound to routes GET endpoint with URI <code>/get</code></li> <li><code>@routes.post('/post')</code> bound to routes POST endpoint with URI <code>/post</code></li> </ol> <p>For Panini, it's equal to:</p> <pre><code>@app.http.get('/get')\nasync def handle_get(request):\n    ...\n\n@app.http.post('/post')\nasync def handle_post(request):\n    ...\n\n# no need to call 'app.router.add_routes(routes)'\n</code></pre> <ol> <li><code>@app.http.get('/get')</code> is the same as <code>@routes.get('/get')</code></li> <li><code>@app.http.post('/post')</code> is the same as <code>@routes.post('/post')</code></li> </ol> <p>You can also use the rest of the syntax of Aoihttp in Panini with <code>@app.http</code> . In fact, Panini just creates an instance of Aiohttp inside, therefore <code>@app.http</code>  is <code>web.RouteTableDef()</code>  from Aiohttp. </p> <p>Let's check how to build a little REST API in Panini:</p> <pre><code>from aiohttp import web\nfrom panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='nats-microservice-that-also-http-rest',\n        host='127.0.0.1',\n        port=4222,\n)\napp.setup_web_server(port=5000)\n\n@app.timer_task(interval=2)  \nasync def publish():\n    for _ in range(10):\n        await app.publish(subject=\"some.publish.subject\", message={'some':'message'})\n\n@app.http.view(\"/path/to/rest/endpoints\")\nclass MyView(web.View):\n\"\"\"\n    HTTP endpoints for REST schema\n    \"\"\"\n\n    async def get(self):\n        # request = self.request\n        return web.Response(text=\"Hello, REST world\")\n\n    async def post(self):\n        # request = self.request\n        return web.Response(text=\"Hello, REST world\")\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>This example demonstrates how to build a class-based view from Aiohttp. To know more about Aiohttp, we recommend checking its documentation: https://docs.aiohttp.org/en/stable/web_quickstart.html#resource-views </p> <p>That's it. Next step - WebSocket server.</p>"},{"location":"0.7.2/How_Panini_works/","title":"How Panini works","text":"<p>If this is your first time here, we recommended installing NATS and going through the quick start before exploring these sections. The current section describes the main components, their parameters, and their attributes:</p> <p>Panini app arguments</p> <p>Panini app functions</p> <p>Incoming message structure</p> <p>How to validate that microservice connected to NATS</p>"},{"location":"0.7.2/How_to_contribute/","title":"\ud83d\udc50 How to contribute","text":""},{"location":"0.7.2/How_to_contribute/#welcome-contributor","title":"Welcome contributor!","text":"<p>First off, thank you for considering contributing to Panini. We are looking for developers to make Panini a great project.</p>"},{"location":"0.7.2/How_to_contribute/#why-you-need-to-read-our-guidelines","title":"Why you need to read our guidelines.","text":"<p>Following these guidelines ensures that you respect the time of the developers managing and developing this open-source project. In return, they reciprocate that respect in addressing your issue, assessing changes, and helping you finalize your pull requests.</p>"},{"location":"0.7.2/How_to_contribute/#your-first-contribution","title":"Your First Contribution","text":"<p>Working on your first Pull Request? You can learn how from this\u00a0free\u00a0series,\u00a0How to Contribute to an Open Source Project on GitHub.</p> <p>Well, how can you help:</p> <ul> <li>suggest new updates\u00a0here</li> <li>review a\u00a0pull request</li> <li>fix an\u00a0issue</li> <li>write a tutorial</li> <li>always follow\u00a0this\u00a0guide for your contributions</li> </ul> <p>At this point, you're ready to make your changes! Feel free to ask for help; everyone is a beginner at first\u00a0\ud83d\ude38</p>"},{"location":"0.7.2/Incoming_Message_Structure/","title":"Incoming message structure","text":"<p>Usage example:</p> <pre><code>@app.listen(subject='some.subject')\nasync def subject_for_requests_listener(msg):\n    subject = msg.subject\n    message = msg.data\n    # handle incoming message\n</code></pre> <p>msg.subject(str) - NATS subject that message comes from</p> <p>msg.data(dict or str or bytes) - analogue of HTTP message's body</p> <p>msg.reply(str) - one-time use subject to send a response</p> <p>msg.sid(str) - subscribe ID that message comes from</p> <p>msg.headers(dict) - any custom dict for external use</p>"},{"location":"0.7.2/Install/","title":"\ud83d\ude9a Install","text":""},{"location":"0.7.2/Install/#prerequisites","title":"Prerequisites:","text":"<p>Before getting started make sure you have all the prerequisites installed:</p> <ul> <li>Python</li> <li>pip</li> <li>NATS</li> <li>Docker (only if you want to run NATS via Docker)</li> </ul> <p>Panini supports Python\u22653.8, we recommend using the latest version</p> <p>NATS should be installed as the documentation suggests, one of the ways is described below. </p> <p>After installation, you need to run NATS.</p>"},{"location":"0.7.2/Install/#installing-nats","title":"Installing NATS","text":"<p>Install via Docker:</p> <pre><code>&gt; docker pull nats:latest\n</code></pre> <p>On Windows:</p> <pre><code>&gt; choco install nats-server\n</code></pre> <p>On Mac OS:</p> <pre><code>&gt; brew install nats-server\n</code></pre>"},{"location":"0.7.2/Install/#running-nats","title":"Running NATS","text":"<p>Simply run the following command:</p> <pre><code>&gt; nats-server\n[1281] 2021/11/01 07:19:20.762736 [INF] Starting nats-server version 2.1.6\n[1281] 2021/11/01 07:19:20.762853 [INF] Git commit [not set]\n[1281] 2021/11/01 07:19:20.763182 [INF] Listening for client connections on 0.0.0.0:4222\n[1281] 2021/11/01 07:19:20.763190 [INF] Server id is NBIDLI72N7ONJZSSFKLL774A7RWCKVHU26X2QI7RFOETJFURXA6CETRB\n[1281] 2021/11/01 07:19:20.763192 [INF] Server is ready\n</code></pre>"},{"location":"0.7.2/Install/#installing-panini","title":"Installing Panini","text":"<p>Install Panini via pip:</p> <pre><code>&gt; pip install panini\n</code></pre> <p>Check that Panini has been installed</p> <pre><code>&gt; pip show panini\nName: panini\nVersion: 0.6.0\nSummary: A python messaging framework for microservices based on NATS\nHome-page: https://github.com/lwinterface/panini\nAuthor: Op Return SA, developers: Andrii Volotskov, Danylo Tiutiushkin, Oleksii Volotskov\nAuthor-email: example@example.com\nLicense: MIT\nLocation: /Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages\nRequires: six, requests, python-json-logger, async-timeout, asyncio-nats-client, prometheus-client, websocket-client, nest-asyncio, nats-python, ujson, yarl, aiohttp, aiohttp-cors\nRequired-by:\n</code></pre> <p>Install Panini via GitHub:</p> <pre><code>&gt; git clone https://github.com/lwinterface/panini.git\n</code></pre>"},{"location":"0.7.2/JetStream/","title":"\u26d3 JetStream","text":"<p>Supported since Panini 0.7.0</p> <p>Since Panini switched from asyncio-nats-client to nats-py, it has become possible to support one of the most important features of NATS 2.0 - JetStream.</p> <p>Core NATS vs NATS Jetstream:</p> <p>Core NATS - default version, stateless messaging, does not guarantee message delivery in certain cases</p> <p>NATS JetStream - is an extension of Core NATS that allows you to store in the broker and replay messages in case of problems.</p> <p>If this is your first time with JetStream, it is recommended that you familiarize yourself with how it works in NATS:</p> <ul> <li>https://docs.nats.io/nats-concepts/jetstream</li> <li>https://www.byronruth.com/grokking-nats-consumers-part-1/</li> </ul> <p>Panini v0.7.0 does not implement an interface to JetStream at the framework level. Instead, it is suggested to use directly nats-py</p> <p>Example JetStream publisher microservice:</p> <p><pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"js_publish\",\n    host=\"127.0.0.1\",\n    port=4222,\n    enable_js=True\n)\n\nlog = app.logger\nNUM = 0\n\n\n@app.on_start_task()\nasync def on_start_task():\n    await app.nats.js_client.add_stream(name=\"sample-stream-1\", subjects=[\"test.*.stream\"])\n\n\ndef get_message():\n    return {\n        \"id\": app.nats.client.client_id,\n    }\n\n\n@app.timer_task(interval=2)\nasync def publish_periodically():\n    subject = \"test.app2.stream\"\n    message = get_message()\n    global NUM\n    NUM+=1\n    message['counter'] = NUM\n    await app.publish(subject=subject, message=message)\n    log.info(f\"sent {message}\")\n\n\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> As you can see in the example, we create a Stream using on_start to make sure the Stream is created before we start sending messages. Also you have to use flag <code>enable_js=True</code> when initialize a panini app.</p> <p>JetStream push-based consumer microservice example:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"js_listen_push\",\n    host=\"127.0.0.1\",\n    port=4222,\n    enable_js=True\n)\n\nlog = app.logger\nNUM = 0\n\n@app.task()\nasync def subscribe_to_js_stream_push():\n    async def cb(msg):\n        log.info(f\"got JS message ! {msg.subject}:{msg.data}\")\n\n    await app.nats.js_client.subscribe(\"test.*.stream\", cb=cb, durable='consumer-1', stream=\"sample-stream-1\")\n\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>JetStream pull-based consumer microservice example:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"js_listen_pull\",\n    host=\"127.0.0.1\",\n    port=4222,\n    enable_js=True\n)\n\nlog = app.logger\nNUM = 0\n\ndef get_message():\n    return {\n        \"id\": app.nats.client.client_id,\n    }\n\n\n@app.task()\nasync def subscribe_to_js_stream_pull():\n    psub = await app.nats.js_client.pull_subscribe(\"test.*.stream\", durable='consumer-2')\n    # Fetch and ack messages from consumer.\n    for i in range(0, 10):\n        msgs = await psub.fetch(1)\n        for msg in msgs:\n            print(msg.data)\n            await msg.ack()\n\n@app.task(interval=1)\nasync def subscribe_to_js_stream_pull():\n    print('some parallel task')\n\n\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>A full-fledged extension of the Panini interface for JetStream is expected in the next versions of Panini.</p>"},{"location":"0.7.2/License/","title":"\ud83d\uddfd License","text":""},{"location":"0.7.2/License/#mit-license","title":"MIT License","text":"<p>Copyright \u00a9 2021 lwinterface</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"0.7.2/Logger/","title":"\ud83d\udccb Logger","text":"<p>What is the Panini internal logger? </p> <p>It is a default python logger with some settings that the Panini team found convenient. If you are using your own logging style, just skip this section.</p> <p>Logger has 2 important parameters:</p> <ul> <li>logger_files_path - the path to the log folder - it can be absolute or relative (will relate to the app root path):</li> </ul> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name='logger_example',\n    host='127.0.0.1',\n    port=4222,\n    logger_files_path='some/relative/path',  # put here absolute or relative path\n)\n\nlog = app.logger\n\nlog.info(\"some log\")  # write log\n</code></pre> <ul> <li>in_separate_process - specify, if you want logger in a separate process or in the main process:</li> </ul> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name='logger_example',\n    host='127.0.0.1',\n    port=4222,\n    logger_in_separate_process=False,  # by default, more intuitive\n    # logger_in_separate_process=True  # more efficient, but needs good understanding of process\n)\n\nlog = app.logger\n\nlog.info(\"some log\")  # write log\n</code></pre>"},{"location":"0.7.2/Logger/#log-config","title":"Log Config:","text":"<p>In the logger we use a simple default config that fits most logger needs:</p> <pre><code>`{\n\"version\": 1,\n// we use False for handling build in errors in our logs\n\"disable_existing_loggers\": false,\n\"formatters\": {\n\"detailed\": {\n\"class\": \"pythonjsonlogger.jsonlogger.JsonFormatter\",\n// notice 'extra' field - that's for extra arguments logging\n\"format\": \"%(created)f %(name)s %(levelname)s %(processName)s %(threadName)s %(message)s %(extra)s\"\n},\n\"simple\": {\n\"class\": \"logging.Formatter\",\n\"format\": \"%(asctime)s %(name)-15s %(levelname)-8s %(message)s\"\n}\n},\n\"handlers\": {\n\"console\": {\n\"class\": \"logging.StreamHandler\",\n\"level\": \"INFO\",\n\"formatter\": \"simple\",\n\"stream\": \"ext://sys.stdout\"\n},\n\"panini\": {\n\"level\": \"DEBUG\",\n\"class\": \"logging.handlers.RotatingFileHandler\",\n\"filename\": \"panini.log\",\n\"mode\": \"a\",\n\"formatter\": \"detailed\",\n\"maxBytes\": 1000000,\n\"backupCount\": 10,\n},\n\"inter_services_request\": {\n\"level\": \"DEBUG\",\n\"class\": \"logging.handlers.RotatingFileHandler\",\n\"filename\": \"inter_services_request.log\",\n\"mode\": \"a\",\n\"formatter\": \"detailed\",\n\"maxBytes\": 1000000,\n\"backupCount\": 10,\n},\n// root logger, that contains all existing logs\n\"app\": {\n\"level\": \"DEBUG\",\n\"class\": \"logging.handlers.RotatingFileHandler\",\n\"filename\": \"app.log\",\n\"mode\": \"a\",\n\"formatter\": \"detailed\",\n\"maxBytes\": 1000000,\n\"backupCount\": 10,\n},\n\"errors\": {\n\"class\": \"logging.FileHandler\",\n\"filename\": \"errors.log\",\n\"mode\": \"a\",\n\"level\": \"ERROR\",\n\"formatter\": \"detailed\"\n},\n// consider your app.name here\n\"app_name\": {\n\"level\": \"DEBUG\",\n\"class\": \"logging.handlers.RotatingFileHandler\",\n// and here also\n\"filename\": \"app_name.log\",\n\"mode\": \"a\",\n\"formatter\": \"detailed\",\n\"maxBytes\": 1000000,\n\"backupCount\": 10,\n}\n},\n\"loggers\": {\n\"panini\": {\n\"handlers\": [\n\"panini\"\n]\n},\n\"inter_services_request\": {\n\"handlers\": [\n\"inter_services_request\"\n]\n},\n// your app_name is here\n\"app_name\": {\n\"handlers\": [\n\"app_name\"\n]\n},\n},\n\"root\": {\n\"level\": \"DEBUG\",\n\"handlers\": [\n\"console\",\n\"errors\",\n\"app\"\n]\n}\n}`\n</code></pre> <p>Also, you can provide a custom log configuration for advanced logging. To do that - just create <code>config/log_config.json</code> file inside your app root path. (see log_config.json.sample)</p> <p>Please notice, that some formatters and loggers will be added to your custom config, but not overwritten if they exist.</p> <p>You can also provide some keywords to the custom log config file that will be replaced by some meaningful data, such as:</p> <pre><code>%MS_NAME% - will be replaced to microservice name (app_name),\n%CLIENT_ID% - will be replaced to client_id from os.environ (advanced),\n\"%DATETIME%\": will be replaced as datetime of app start in human readable string format,\n</code></pre> <p>Notice, that these keywords work only inside the \"filename\" log configuration.</p>"},{"location":"0.7.2/Logger/#additional-logger-settings","title":"Additional logger settings:","text":"<p>If you want to be able to log some extra parameters, these things should be done next:</p> <pre><code>from panini.utils.logger import get_logger\n\nlog = get_logger('app')\n\nlog.warning('some log', extra_parameter='some extra parameter')\n</code></pre> <p>These extra parameters will be logged with each log - see %(extra)s argument in the default configuration format.</p> <p>Notice that extra parameters will be added to your logs only if you add \"%(extra)s\" to your log config formatter.</p>"},{"location":"0.7.2/Middlewares/","title":"\ud83d\udd96 Middlewares","text":"<p>A \"*middleware\"* (in common meaning) is a function that works with every request before it is processed by a message handler. And also with every response before returning it. </p> <p>Panini middleware works similar to Django or Flask-like frameworks, and also offers to use middleware for sending messages. </p> <p>Example of an app with such middleware:</p> <pre><code>import time\nfrom panini import app as panini_app\nfrom panini.middleware import Middleware\n\napp = panini_app.App(\n    service_name=\"another_panini_app\",\n    host=\"127.0.0.1\",\n    port=4222,\n)\n\nclass ProcessTimeMiddleware(Middleware):\n    async def send_request(self, subject: str, message, request_func, *args, **kwargs):\n\"\"\"\n        measure request processing time and add to a response\n        \"\"\"\n        start_time = time.time()\n        response = await request_func(subject, message, *args, **kwargs)\n        process_time = time.time() - start_time\n        response[\"process-time\"] = str(process_time)\n        return response\n\n@app.task(interval=1)\nasync def publish_periodically():\n    message = {\"request_type\":\"Bitcoin price\"}\n    result = await app.request(subject=\"some.request.subject\", message=message)\n    # received response: {\"bitcoin-price\": 100000, \"process-time\": '0.0051320'}\n    print(f\"requested Bitcoin price, result: {result}\")\n\n@app.listen(\"some.publish.subject\")\nasync def receive_messages(msg):\n    print(\"received request for Bitcoin price\")\n    bitcoin_price = 100000\n    # response to send: {\"bitcoin-price\": 100000}\n    return {\"bitcoin-price\": bitcoin_price}\n\nif __name__ == \"__main__\":\n    app.add_middleware(ProcessTimeMiddleware)\n    app.start()\n</code></pre> <p>As you can see <code>ProcessTimeMiddleware</code> measures the request time and adds it to the response in the <code>process-time</code> field.</p> <p>Of course, in real tasks, the listener will be in another microservice. We put the task and the listener in one microservice to simplify this example.</p>"},{"location":"0.7.2/Middlewares/#middleware-detailed","title":"Middleware detailed","text":"<p>In Panini we have 2 core operations to communicate between microservices:</p> <ul> <li>send operation (publish or request)</li> <li>listen operation (listen to any of send operations)</li> </ul> <p>Using Panini Middleware we can apply modifications to both of these operations \"before\" and \"after\" they are called.</p> <p>How it works:</p> <ul> <li>It takes each operation in your application.</li> <li>It can then do something to that operation or run any needed code (before the operation is called).</li> <li>Then it passes the operation to be processed by the rest of the application.</li> <li>It then takes the response generated by the application.</li> <li>It can do something to that response or run any needed code (after an operation is called**)**.</li> <li>Then it returns the response.</li> </ul>"},{"location":"0.7.2/Middlewares/#middleware-interface","title":"Middleware Interface:","text":"<p>The basic interface of Panini Middleware looks like this:</p> <pre><code>class Middleware:\n        def __init__(self, *args, **kwargs):\n        pass\n\n    async def send_publish(self, subject: str, message, publish_func, *args, **kwargs):\n\"\"\"\n        :param subject: str\n        :param message: any of supported types\n        :param publish_func: Callable for publish\n        :return: None\n        \"\"\"\n\n    async def listen_publish(self, msg, callback):\n\"\"\"\n        :param msg: Msg\n        :param callback: Callable, that will be called on receive message\n        :return: None\n        \"\"\"\n\n    async def send_request(self, subject: str, message, request_func, *args, **kwargs):\n\"\"\"\n        :param subject: str\n        :param message: any of supported types\n        :param request_func: Callable for request\n        :return: any of supported types\n        \"\"\"\n\n    async def listen_request(self, msg, callback):\n\"\"\"\n        :param msg: Msg\n        :param callback: Callable, that will be called on receive message\n        :return: any of supported types\n        \"\"\"\n\n        # and composed functions for better user experience:\n        async def send_any(self, subject: str, message, send_func, *args, **kwargs):\n\"\"\"\n        :param subject: str\n        :param message: any of supported types\n        :param send_func: Callable for send\n        :return: None or any of supported types\n        \"\"\"\n\n    async def listen_any(self, msg, callback):\n\"\"\"\n        :param msg: Msg\n        :param callback: Callable, that will be called on receive message\n        :return: None or any of supported types\n        \"\"\"\n</code></pre> <p>*Note here, that <code>send_any</code> will do the job for <code>send_request</code> and <code>send_publish</code>, if they are not implemented, but won't override them, if they exist. And the same thing with <code>listen_any</code>.</p>"},{"location":"0.7.2/Middlewares/#examples","title":"Examples","text":""},{"location":"0.7.2/Middlewares/#processtimemiddleware","title":"ProcessTimeMiddleware","text":"<p>Let's check closer the very first example in this section. That middleware adds a <code>process-time</code> parameter to a response. The <code>process-time</code> parameter contains the time in seconds it takes to send &amp; process the request. The <code>send_request</code> function receives:</p> <ul> <li>The <code>subject</code> &amp; <code>message</code>: such as common request function.</li> <li>A function <code>request_func</code>, that receives subject, message &amp; args/kwargs.<ul> <li>This function will send a request to the corresponding subject with a message provided.</li> <li>This function will also call all other middlewares (if they exist) inside the app.</li> <li>Then it returns the response before returning it.</li> </ul> </li> <li>You can further modify the response before returning it.</li> </ul> <pre><code>import time\n\nfrom panini.middleware import Middleware\n\nclass ProcessTimeMiddleware(Middleware):\n    async def send_request(self, subject: str, message, request_func, *args, **kwargs):\n        start_time = time.time()\n        response = await request_func(subject, message, *args, **kwargs)\n        process_time = time.time() - start_time\n        response[\"process-time\"] = str(process_time)\n        return response\n</code></pre> <p>To register middleware it needs to add ProcessTimeMiddleware before <code>app.start()</code></p> <pre><code>app.add_middleware(ProcessTimeMiddleware)\n</code></pre>"},{"location":"0.7.2/Middlewares/#testingmiddleware","title":"TestingMiddleware","text":"<p>Imagine, that you want to easily switch to test mode in your application, which means:</p> <ul> <li>You want to always send it to different subjects (the same subject, but with <code>test</code> prefix)</li> <li>You want to remove some meaningful data from requests &amp; responses</li> </ul> <pre><code>from panini.middleware import Middleware\n\nclass TestingMiddleware(Middleware):\n    def __init__(self, meaningful_key):\n        self.meaningful_key = meaningful_key\n\n    async def send_any(self, subject: str, message, send_func, *args, **kwargs):\n                subject = \"test.\" + subject\n        if self.meaningful_key in message:\n            del message[self.meaningful_key]\n\n        response = await send_func(subject, message, *args, **kwargs)\n\n        if self.meaningful_key in response:\n            del response[self.meaningful_key]\n        return response\n\n    async def listen_any(self, msg, callback):\n        if self.meaningful_key in msg.data:\n            del msg.data[self.meaningful_key]\n\n        response = await callback(msg)\n\n        if self.meaningful_key in response:\n            del response[self.meaningful_key]\n        return response\n</code></pre> <p>Then, you need to add TestingMiddleware and specify the <code>meaningful_key</code> parameter like this:</p> <pre><code>app.add_middleware(TestingMiddleware, \"meaningful_key\")\n</code></pre> <p>\ud83d\udca1</p><p>Please, notice, that you should only use async interface for creating Middlewares as written in examples. The synchronous interface doesn't support middleware. But add_middleware is called synchronously as in the example above</p>"},{"location":"0.7.2/Middlewares/#built-in-middlewares","title":"Built-in-middlewares","text":"<p>You can use some built-in middlewares for common cases, already implemented in Panini:</p> <ul> <li><code>ErrorMiddleware</code> - call callback when an error rises</li> <li><code>NATSTimeoutMiddleware</code> - logs NATS timeout</li> <li><code>PrometheusMonitoringMiddleware</code> - measure performance of app, more detailed"},{"location":"0.7.2/Middlewares/#hierarchical-middlewares","title":"Hierarchical Middlewares","text":"<p>If you want to make hierarchical middleware, with more than 1 inheritance -  please, recall methods, from your base middleware:</p> <pre><code>class FooMiddleware(Middleware):\n    async def send_publish(self, subject: str, message, publish_func, *args, **kwargs):\n        print(\"In Foo Middleware: publish\")\n        await publish_func(subject, message, *args, **kwargs)\n\nclass BarMiddleware(FooMiddleware):\n    async def send_request(self, subject: str, message, request_func, *args, **kwargs):\n        print(\"In Bar Middleware: request\")\n                return await request_func(subject, message, *args, **kwargs)\n\n    async def send_publish(self, subject: str, message, publish_func, *args, **kwargs):\n        return await super(BarMiddleware, self).send_publish(subject, message, *args, **kwargs)\n</code></pre>"},{"location":"0.7.2/Panini_App_Arguments/","title":"App Arguments","text":"<p>Panini app available on <code>panini.app.App</code></p> <p>Usage example:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n        service_name='listener_app',\n        host='127.0.0.1',\n        port=4222,\n)\n</code></pre> <p>Parameters:</p> <ul> <li>host(str): NATS broker host</li> <li>port(int): NATS broker port</li> <li>service_name(str): Name of microservice, will be the part of NATS client_id if you didn't set custom client_id</li> <li>servers(list): Alternative to NATS broker host+NATS broker port. Allows microservice to establish a connection to multiple NATS brokers</li> <li>client_id(str): Custom NATS client_id</li> <li>reconnect(bool): Connects again if a lost connection to NATS broker</li> <li>max_reconnect_attempts(int): Number of attempts to reconnect</li> <li>reconnecting_time_sleep(int): Pause between reconnections</li> <li>allocation_queue_group(str): Name of the queue group. Incoming traffic allocates between group members.</li> <li>logger_required(bool): Logger required for the project, if not - default logger will be provided</li> <li>logger_files_path(str): Main path for logs</li> <li>logger_in_separate_process(bool): Use log in the same or in different process</li> <li>pending_bytes_limit(int): Limit of bytes for a single incoming message</li> <li>auth(dict): Dict with arguments for authentication</li> </ul>"},{"location":"0.7.2/Panini_App_Functions/","title":"App Functions","text":""},{"location":"0.7.2/Panini_App_Functions/#decorators","title":"Decorators","text":"<p><code>@app.task()</code> - an asyncio task that is launched with the application, executed once</p> <p>Usage example:</p> <pre><code>@app.task()\nasync def publish():\n    while True:\n        message = get_some_update()\n        await app.publish(subject='some.subject', message=message)\n</code></pre> <p><code>@app.task(interval=1)</code> - same asyncio task but runs at a given interval</p> <p>Usage example:</p> <pre><code>@app.task(interval=2)\nasync def your_periodic_task():\n    for _ in range(10):\n        await app.publish(subject='some.publish.subject', message={'some':'data'})\n</code></pre> <p>Supported arguments:</p> <ul> <li>interval(int or float): waiting time between periodic task executions</li> </ul> <p><code>@app.listen(subject=\"some.subject\")</code> - subscribe to the specified subject and run a callback for every incoming message</p> <p>Usage example:</p> <pre><code>@app.listen(subject='some.subject')\nasync def subject_for_requests_listener(msg):\n    subject = msg.subject\n    message = msg.data\n    # handle incoming message\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject(str): NATS subject to subscribe</li> </ul>"},{"location":"0.7.2/Panini_App_Functions/#functions","title":"Functions","text":"<p>Parameters from all functions:</p> <ul> <li>subject(str): NATS subject to send or subscribe</li> <li>msg(): NATS single message object to receive <li>reply_to(str): An additional subject for a response, relevant if you want to request from one microservice but receive by another one</li> <li>force(bool): This flag trigger immediately sends all messages in a buffer. Otherwise, the messages are send periodically. Sending frequency depends on how many asyncio tasks are running in the loop</li> <li>data_type( or str): allows choosing a type of message body to send or receive. More details  <li>timeout(int or float): only for requests, like HTTP request timeout but for NATS requests</li> <li>ssid(str): subscription ID</li> <li>callback(CoroutineType): function to call when received a new message</li> <p>app.publish</p> <p>Usage example:</p> <pre><code>await app.publish(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported parameters:</p> <ul> <li>subject</li> <li>message</li> <li>reply_to</li> <li>force</li> <li>data_type</li> </ul> <p>response - None</p> <p>app.request</p> <p>Usage example:</p> <pre><code>response = await app.request(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported parameters:</p> <ul> <li>subject</li> <li>message</li> <li>timeout</li> <li>data_type</li> </ul> <p>response - message body, type depends on given data_type</p> <p>app.nats.publish_from_another_thread</p> <p>Usage example:</p> <pre><code>app.nats.publish_from_another_thread(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject</li> <li>message</li> <li>reply_to</li> <li>force</li> <li>data_type</li> </ul> <p>response - None</p> <p>app.request_from_another_thread</p> <p>Usage example:</p> <pre><code>response = await app.request_from_another_thread(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported parameters:</p> <ul> <li>subject</li> <li>message</li> <li>timeout</li> <li>data_type</li> </ul> <p>response - message body, type depends on given data_type</p> <p>app.subscribe_new_subject</p> <p>Usage example:</p> <pre><code>await app.subscribe_new_subject(subject='some.subject', callback=some_funcion)\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject</li> <li>callback</li> </ul> <p>response - subscription ID</p> <p>app.unsubscribe_subject</p> <p>Usage example:</p> <pre><code>await app.unsubscribe_subject(subject='some.subject')\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject</li> </ul> <p>response - None</p> <p>app.unsubscribe_ssid</p> <p>Usage example:</p> <pre><code>await app.unsubscribe_ssid(ssid='some.subject')\n</code></pre> <p>Supported arguments:</p> <ul> <li>ssid</li> </ul> <p>response - None</p> <p>app.disconnect</p> <p>Usage example:</p> <pre><code>await app.disconnect()\n</code></pre> <p>app.publish_sync</p> <p>Usage example:</p> <pre><code>app.publish_syn(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported parameters:</p> <ul> <li>subject</li> <li>message</li> <li>reply_to</li> <li>force</li> <li>data_type</li> </ul> <p>response - None</p> <p>app.request_sync</p> <p>Usage example:</p> <pre><code>await app.request_sync(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported parameters:</p> <ul> <li>subject</li> <li>message</li> <li>timeout</li> <li>data_type</li> </ul> <p>response - message body, type depends on given data_type</p> <p>app.subscribe_new_subject_sync</p> <p>Usage example:</p> <pre><code>await app.subscribe_new_subject(subject='some.subject', callback=some_funcion)\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject</li> <li>callback</li> </ul> <p>response - subscription ID</p> <p>app.unsubscribe_subject_sync</p> <p>Usage example:</p> <pre><code>await app.unsubscribe_subject(subject='some.subject')\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject</li> </ul> <p>response - None</p> <p>app.disconnect_sync</p> <p>Usage example:</p> <pre><code>app.disconnect_sync()\n</code></pre> <p>app.middlewares</p> <p>Usage example:</p> <pre><code>app.add_middleware(SomeMiddleware)\n</code></pre> <p>Supported arguments:</p> <ul> <li>cls(class 'Middleware')</li> </ul>"},{"location":"0.7.2/Panini_Validation/","title":"How to validate that microservice connected to NATS","text":"<ol> <li>Make sure that NATS server is running, how to run it  <li>Create a simple app that periodically sends a message by one asyncio task and receives the message by another task. The whole app is a single module  <code>app.py</code>:</li> <pre><code>from panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='quickstart-app',\n        host='127.0.0.1',\n        port=4222,\n)\n\n@app.task(interval=1)\nasync def publish_periodically():\n        await app.publish(subject=\"some.publish.subject\", message={'some_key':'Hello stream world'})\n\n@app.listen(\"some.request.subject\")\nasync def receive_messages(msg):\n    subject = msg.subject\n    message = msg.data\n        print('Yai! I got new message from stream: {subject}:{message}')\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <ol> <li>Run app.py:</li> </ol> <pre><code>&gt; python3 app.py\n======================================================================================\nPanini service connected to NATS..\nid: 2\nname: quickstart-app__non_docker_env_98846__896705\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n\nYai! I got new message from stream: {subject}:{message}\nYai! I got new message from stream: {subject}:{message}\nYai! I got new message from stream: {subject}:{message}\nYai! I got new message from stream: {subject}:{message}\n</code></pre> <p>Check panini app as a client of NATS broker:</p> <pre><code>curl http://127.0.0.1:8222/connz\n</code></pre> <p>You should get something like:</p> <pre><code>{\n  \"server_id\": \"NAKBPTP3AFN3XG4CJBMARGTJPWQS6M6DH2OZ4S5F6MAV4DXEJKXNIVC6\",\n  \"now\": \"2021-05-02T22:36:11.940857451Z\",\n  \"num_connections\": 1,\n  \"total\": 1,\n  \"offset\": 0,\n  \"limit\": 1024,\n  \"connections\": [\n    {\n      \"cid\": 2,\n      \"ip\": \"192.168.240.21\",\n      \"port\": 35454,\n      \"start\": \"2021-04-27T18:05:31.848989012Z\",\n      \"last_activity\": \"2021-05-02T22:36:11.882566724Z\",\n      \"rtt\": \"214\u00b5s\",\n      \"uptime\": \"5d4h30m40s\",\n      \"idle\": \"0s\",\n      \"pending_bytes\": 0,\n      \"in_msgs\": 4,\n      \"out_msgs\": 4,\n      \"in_bytes\": 345,\n      \"out_bytes\": 345,\n      \"subscriptions\": 1,\n      \"name\": \"quickstart-app__non_docker_env_98846__896705\",\n      \"lang\": \"python3\",\n      \"version\": \"0.9.2\"\n    }\n</code></pre> <p>All your microservices under field <code>connections</code></p>"},{"location":"0.7.2/Quickstart/","title":"\ud83c\udf73 Quickstart","text":"<p>Panini is a modern framework for fast and straightforward microservice development. It's a Flask-like solution but for NATS streaming. </p> <p>For this quickstart, we expect the reader to have a minimal experience with:</p> <ul> <li>Python</li> <li>basic knowledge about NATS</li> <li>FastAPI or Aiohttp or Flask</li> </ul>"},{"location":"0.7.2/Quickstart/#a-simple-listener-app-example","title":"A simple listener app example","text":"<p>A minimal app with one stream endpoint, one request endpoint, and one periodic task might look like this:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n        service_name='listener_app',\n        host='127.0.0.1',\n        port=4222,\n)\n\n@app.listen(\"some.subject.for.request\")\nasync def request_listener(msg):\n\"\"\" request endpoint \"\"\"\n    print(f\"request {msg.data} from {msg.subject} has been processed\")\n    return {\"success\": True, \"message\": \"request has been processed\"}\n\n@app.listen(\"some.subject.for.stream\")\nasync def stream_listener(msg):\n\"\"\" stream endpoint \"\"\"\n    print(f\"event {msg.data} from {msg.subject} has been processed\")\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>What's going on here?</p> <ol> <li>Imported Panini.</li> <li>Initialized app. Created an instance of class App from module panini with any microservice name, NATS host, and port.</li> <li>First <code>@app.listen</code> registers the listening subject <code>\"some.subject.for.request\"</code> with <code>request_listener</code>. Every time this app receives a request addressed to <code>\"some.subject.for.request\"</code>, the function <code>request_listener</code> is called to process it, then it sends a return response back to an addressee.</li> <li>Secondly <code>@app.listen</code> register the listening subject <code>\"some.subject.for.stream\"</code> with <code>stream_listener</code>. Same as with <code>request_listener</code> but without sending the result back.</li> <li><code>app.start()</code> runs an app. No code under this command will ever be called.</li> </ol> <p>Save the above code to file listener*_*app.py.</p> <p>\ud83d\udca1</p><p> The current function expects only JSON formattable returns, dict or list. However, you can also specify it as string or bytes. More details about this in Datatypes section.</p> <p>Make sure that you have all prerequisites from Install. Open the terminal to run the app:</p> <pre><code>&gt; python3 listener_app.py\n======================================================================================\nPanini service connected to NATS..\nid: 3\nname: listener_app__non_docker_env_270377__75017\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n</code></pre> <p>That's it. Now let's create something that will generate messages.</p>"},{"location":"0.7.2/Quickstart/#a-simple-app-example-that-generates-messages","title":"A simple app example that generates messages","text":"<p>Our goal here is to trigger endpoints from listener app above: </p> <ul> <li>\"some.subject.for.request\"  - request something, receive response</li> <li>\"some.subject.for.stream\" - send some event without waiting for response</li> </ul> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n        service_name='sender_app',\n        host='127.0.0.1',\n        port=4222,\n)\n\n@app.task(interval=1)\nasync def request_periodically():\n        message = {\"data\":\"request1234567890\"}\n    response = await app.request(\n        subject=\"some.subject.for.request\", \n        message=message,\n    )\n    print(response)\n\n\n@app.task(interval=1)\nasync def publish_periodically():\n    message = {\"data\":\"event1234567890\"}\n    await app.publish(\n        subject=\"some.subject.for.stream\", \n        message=message,\n    )\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>What's new here:</p> <ol> <li>First, <code>@app.task</code> registers function <code>request_periodically</code> to call it periodically at given interval, each 1 second in the example.</li> <li>Function <code>app.request</code> sends requests, asynchronously waits for a response.</li> <li>The second <code>@app.task</code> does the same as the first one but for publishing.</li> <li>Function <code>app.publish</code> sends a message like a request but without expecting any response. Fire and forget.</li> </ol> <p>Save the code to new file sender_app.py.</p> <p>Make sure that listener_app.py keeps running, then open a new terminal session to run the sender app:</p> <pre><code>&gt; python3 sender_app.py\n======================================================================================\nPanini service connected to NATS..\nid: 3\nname: sender_app__non_docker_env_270377__75017\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n</code></pre> <p>Note that in the terminal session where you run listener_app.py you should see received requests and events:</p> <pre><code>event {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\nevent {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\nevent {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\nevent {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\nevent {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\nevent {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\n</code></pre>"},{"location":"0.7.2/Quickstart/#more-possibilities","title":"More possibilities","text":"<p>In the first example, we created an application that listens for messages, in the second example, an application that sends messages. Panini allows you to freely combine sending and receiving messages in one application. </p> <p>Let's check out what else you can do with Panini using a minimal interface:</p> <ul> <li>One-time tasks on start. Similar to the above periodic task but without <code>interval</code> argument</li> </ul> <pre><code>@app.task()\nasync def publish():\n    while True:\n        message = get_some_update()\n        await app.publish(subject='some.subject', message=message)\n</code></pre> <ul> <li>Synchronous endpoints</li> </ul> <pre><code>@app.task(interval=2)\ndef your_periodic_task():\n    for _ in range(10):\n        app.publish_sync(\n            subject='some.publish.subject', \n            message={'some':'data'}\n        )\n</code></pre> <ul> <li>Accept different datatypes: dict, str, bytes</li> </ul> <pre><code>@app.timer_task(interval=2)\ndef your_periodic_task():\n    for _ in range(10):\n        app.publish_sync(\n            subject='some.publish.subject', \n            message=b'messageinbytestosend', \n            data_type=bytes\n        )\n</code></pre> <ul> <li>Create middlewares for NATS messages</li> </ul> <pre><code>from panini.middleware import Middleware\n\nclass MyMiddleware(Middleware):\n\n    async def send_publish(self, subject, message, publish_func, **kwargs):\n        print('do something before publish')\n        await publish_func(subject, message, **kwargs)\n        print('do something after publish')\n\n    async def listen_publish(self, msg, cb):\n        print('do something before listen')\n        await cb(msg)\n        print('do something after listen')\n\n    async def send_request(self, subject, message, request_func, **kwargs):\n        print('do something before send request')\n        result = await request_func(subject, message, **kwargs)\n        print('do something after send request')\n        return result\n\n    async def listen_request(self, msg, cb):\n        print('do something before listen request')\n        result = await cb(msg)\n        print('do something after listen request')\n        return result\n</code></pre> <ul> <li> <p>Create HTTP endpoints with\u00a0Aiohttp\u00a0and NATS endpoints all together in one microservice</p> <pre><code>from aiohttp import web\n\n@app.listen('some.publish.subject')\nasync def subject_for_requests_listener(msg):\n    handle_incoming_message(msg.subject, msg.data)\n\n@app.http.get('/get')\nasync def web_endpoint_listener(request):\n\"\"\"\n    Single HTTP endpoint\n    \"\"\"\n    return web.Response(text=\"Hello, world\")\n\n@app.http.view('/path/to/rest/endpoints')\nclass MyView(web.View):\n\"\"\"\n    HTTP endpoints for REST schema\n    \"\"\"\n    async def get(self):\n        request = self.request\n        return web.Response(text=\"Hello, REST world\")\n\n    async def post(self):\n        request = self.request\n        return web.Response(text=\"Hello, REST world\")\n</code></pre> </li> <li> <p>Built-in traffic balancing between instances of the microservice if you have high loads</p> </li> </ul> <pre><code>app = panini_app.App(\n        service_name='async_publish',\n        host='127.0.0.1',\n        allocation_queue_group='group24', \n        port=4222,\n)\n\n# incoming traffic will be distributed among \n# all microservices that are in the \"group24\"\n</code></pre> <p>Need more examples? Check here.</p>"},{"location":"0.7.2/Testing/","title":"\ud83d\udd27 Testing","text":"<p>Panini testing is possible with various testing frameworks.  Here we will show testing based on pytest framework.</p>"},{"location":"0.7.2/Testing/#using-testclient","title":"Using TestClient","text":"<p>Import <code>TestClient</code>.</p> <p>Create a <code>TestClient</code> using pytest.fixture by passing it to the function that runs panini.</p> <p>TestClient object <code>.start()</code> will start the panini app for testing.</p> <p>Create <code>functions</code> with a name that starts with <code>test_</code> (this is standard <code>pytest</code> convention).</p> <p>Use the <code>TestClient</code> object for NATS communication the same way you would do with <code>panini</code> </p> <p>Panini uses nats-python synchronous NATS client for testing</p> <p>Write simple <code>assert</code> statements with the standard Python expressions that you need to check (<code>pytest</code> standard).</p> <pre><code>import pytest\nfrom panini import app as panini_app\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    app = panini_app.App(\n        service_name=\"test\",\n        host=\"127.0.0.1\",\n        port=4222\n    )\n\n    @app.listen(\"main.subject\")\n    def main_subject(msg):\n        return {\"message\": \"Hello World!\"}\n\n    app.start()\n\n@pytest.fixture\ndef client():\n    client = TestClient(run_panini).start()\n    yield client\n    client.stop()\n\ndef test_main_subject(client):\n    response = client.request(\"main.subject\", {})\n    assert response[\"message\"] == \"Hello World!\"\n</code></pre> <p>\ud83d\udd25</p><p> Notice that the testing functions are normal def, not async def. Also, the calls to the client are also normal calls, not using await. This allows you to use pytest directly without complications.</p> <p>\ud83d\udee0</p><p> Notice that panini TestClient will run a panini app in a  different process.  The Windows and Mac platforms have limitations for transferring objects to a different process. So we have to use  run_panini function that will implement or import our app, and we must use  fixtures to setup TestClient.</p> <p>\ud83d\udd11</p><p>  Notice that if you use pytest.fixture without scope the panini App will setup and teardown for each test. If you don't want this - please use pytest.fixture(scope=\"module)</p>"},{"location":"0.7.2/Testing/#separating-tests","title":"Separating tests","text":"<p>In a real application, you mostly would have your tests in a different file.</p> <p>Your Panini app can also be in different files or modules.</p>"},{"location":"0.7.2/Testing/#panini-app-file","title":"Panini app file","text":"<p>Let's say you have a file <code>main.py</code> with your Panini app:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.listen(\"main.subject\")\ndef main_subject(msg):\n    return {\"message\": \"Hello World!\"}\n\nif __name__ == '__main__':\n    app.start()\n</code></pre>"},{"location":"0.7.2/Testing/#testing-file","title":"Testing file","text":"<p>Then you could have a file <code>test_main.py</code> with your tests, and import your app from the <code>main</code> module (<code>main.py</code>):</p> <pre><code>import pytest\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    from .main import app\n    app.start()\n\n@pytest.fixture\ndef client():\n    client = TestClient(run_panini).start()\n    yield client\n    client.stop()\n\ndef test_main_subject(client):\n    response = client.request(\"main.subject\", {})\n    assert response[\"message\"] == \"Hello World!\"\n</code></pre>"},{"location":"0.7.2/Testing/#advanced-testing","title":"Advanced testing","text":"<p>Now, let's dig into more details to see how to test different parts.</p> <p>\u2699</p><p> Under the hood, TestClient will run your panini application inside the different process. And will communicate with it only using NATS messaging. This is how you can simulate your panini app activity.</p> <p>\ud83d\udee0</p><p>TestClient will run 2 NATS clients for testing (one for sending, and one for listening). The sending NATS client is in the main Thread, while the listening client can be in a separate thread.</p>"},{"location":"0.7.2/Testing/#error-testing","title":"Error testing","text":"<p>Let's say we need to check that the subject always requires an authorization.</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.listen(\"subject.with.authorization\")\ndef get_secret(msg):\n    if \"authorization\" not in msg.data:\n        raise ValueError(\"You need to be authorized, to get the secret data!\")\n    return {\"secret\": \"some meaningful data\"}\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p>Let's create a test for this example</p> <pre><code>import pytest\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\n@pytest.fixture(scope=\"module\")\ndef client():\n    client = TestClient(run_panini).start()\n    yield client\n    client.stop()\n\ndef test_secret_subject(client):\n    response = client.request(\"subject.with.authorization\", {\"authorization\": \"token\"})\n    assert response[\"secret\"] == \"some meaningful data\"\n\ndef test_unauthorized_secret_subject(client):\n    with pytest.raises(OSError):\n        client.request(\"subject.with.authorization\", {})\n</code></pre> <p>We can use this method of testing, but if we take a better look - it's strange that we are getting a <code>OSError</code> instead of a <code>ValueError</code> Also, the tests will run for an extremely long time because of nats-timeout.</p> <p>The reason for this is that <code>TestClient</code> is a separate NATS service, that performs a simple request in our case. It does not get the response, because of an error on the application side.</p> <p>But still, let's modify a bit our functions, to get the more obvious result:</p> <pre><code>@app.listen(\"subject.with.authorization\")\ndef get_secret(msg):\n    if \"authorization\" not in msg.data:\n        return {\"success\": False, \"message\": \"You have to be authorized, to get the secret data!\"}\n    return {\"success\": True, \"secret\": \"some meaningful data\"}\n</code></pre> <p>And the test function will look like this:</p> <pre><code>def test_unauthorized_secret_subject(client):\n    response = client.request(\"subject.with.authorization\", {})\n    assert response[\"success\"] is False\n    assert response[\"message\"] == \"You have to be authorized, to get the secret data!\"\n</code></pre> <p>So we get the results faster and in a more obvious way.</p>"},{"location":"0.7.2/Testing/#testing-microservice-with-dependencies","title":"Testing microservice with dependencies","text":"<p>Let's say we want to test an authorization application, which depends on another panini application, that fetches data from a DB.</p> <p>For our testing purpose, we don't want to create &amp; support the database, because our application does not have a direct dependency on DB.</p> <p>Using <code>TestClient</code> we can <code>mock</code> the communication between those applications. </p> <p>Let's dive into the code:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"authorization_microservice\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.listen(\"get.token\")\nasync def get_token(msg):\n    if \"email\" not in msg.data or \"password\" not in msg.data:\n        return {\"message\": \"You should provide email &amp; password to authorize\"}\n    response = await app.request(\"db.authorization\", {\"email\": msg.data[\"email\"], \"password\": msg.data[\"password\"]})\n    return {\"token\": response[\"db_token\"]}\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p>And then, apply <code>mocking</code> using <code>TestClient</code> object <code>.listen</code> function.</p> <pre><code>import pytest\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\nfake_db = {\"test_email\": \"test_token\"}\n\n@pytest.fixture()\ndef client():\n    client = TestClient(run_panini)\n\n    @client.listen(\"db.authorization\")  # mock db.authorization subject\n    def authorize(msg):\n        return {\"db_token\": fake_db[msg.data[\"email\"]]}  # provide testing data\n\n    client.start()\n    yield client\n    client.stop()\n\ndef test_get_token(client):\n    response = client.request(\"get.token\", {\"email\": \"test_email\", \"password\": \"test_password\"})\n    assert response[\"token\"] == \"test_token\"\n</code></pre> <p>\ud83d\udca1</p><p>Notice that you have to call @client.listen decorator before client.start()</p>"},{"location":"0.7.2/Testing/#testclient-publish-wait","title":"TestClient publish &amp; wait","text":"<p>We strongly recommend using other tools for testing (like <code>client.request</code> &amp; <code>client.listen</code> only), but sometimes we need a specific <code>client.publish</code> &amp; <code>client.wait</code> to test the panini application.</p> <p>\ud83d\udcd6</p><p>client.wait is used to manually wait for @client.listen callback to be called. It was previously done automatically</p> <p>\u261d</p><p>You should specify client.start(do_always_listen=False) to be able to use client.wait</p> <p>Example for <code>client.publish</code> &amp; <code>client.wait</code>:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.listen(\"start\")\nasync def start(msg):\n    await app.publish(\"app.started\", {\"success\": True})\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p>And testing file:</p> <pre><code>import pytest\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\nis_app_started = False\n\n@pytest.fixture()\ndef client():\n    client = TestClient(run_panini)\n\n    @client.listen(\"app.started\")\n    def app_started(msg):\n        global is_app_started\n        is_app_started = True\n\n    client.start(do_always_listen=False)\n    yield client\n    client.stop()\n\ndef test_get_token(client):\n    assert is_app_started is False\n    client.publish(\"start\", {})\n    client.wait(1)  # wait for @client.listen callback to work\n    assert is_app_started is True\n</code></pre> <p>\ud83d\udca1</p><p>Use client.publish only, when @client.listen returns nothing or subject. But you will need another subject, to check, if the call was successful.</p> <p>Example for <code>client.wait</code>:</p> <p>Let's say you want to test <code>@app.task</code> job:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.task()\nasync def task():\n    await app.publish(\"task.job\", {\"job\": \"test\"})\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p>You can use <code>@client.listen</code> and <code>client.wait</code> for this:</p> <pre><code>import pytest\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\ntask_data = None\n\n@pytest.fixture()\ndef client():\n    client = TestClient(run_panini)\n\n    @client.listen(\"task.job\")\n    def app_started(msg):\n        global task_data\n        task_data = msg.data[\"job\"]\n\n    client.start(do_always_listen=False)\n    yield client\n    client.stop()\n\ndef test_get_token(client):\n    assert task_data is None\n    client.wait(1)  # wait for @client.listen callback to work\n    assert task_data == \"test\"\n</code></pre>"},{"location":"0.7.2/WebSocket_server/","title":"\ud83e\udd85 WebSocket server example","text":"<p>Panini also uses Aiohttp for WebSockets. Let's see how it works using the example below.</p> <p>Suppose we want to create a microservice - a gateway between NATS stream and WebSockets stream. It subscribes to the desired NATS subject from a frontend and broadcasts them to a frontend in \"live mode\". To implement this we need:</p> <ul> <li>Web interface with web socket connection</li> <li>GET endpoint to upload interface</li> <li>POST endpoint to subscribe/unsubscribe to NATS subjects</li> <li>WSS endpoint to receive live messages</li> <li>Some NATS message producer to test microservice</li> <li>Main logic that handles subscribe/unsubscribe requests</li> </ul> <p>Let's split the app into two modules. One for the main app - <code>main.py</code> and another for subscribe/unsubscribe request handler &amp; web page - <code>handler.py</code> </p> <p><code>main.py</code>:</p> <pre><code>import uuid\nimport random\nimport json\nfrom aiohttp import web\nfrom panini import app as panini_app\nfrom handler import WSSManager, html\n\napp = panini_app.App(\n    service_name=\"async_NATS_WSS_bridge\",\n    host='127.0.0.1',\n    port=4222,\n)\napp.setup_web_server(port=5001)\nlogger = app.logger\n\nasync def incoming_messages_callback(subscriber, msg, **kwargs):\n\"\"\"\n        app calls it for each new message from\n        NATS and redirects the message\n        \"\"\"\n    try:\n        await subscriber.send_str(\n            json.dumps({\"subject\": msg.subject, \"data\": msg.data})\n        )\n    except Exception as e:\n        logger.error(f\"error: {str(e)}\")\n\nmanager = WSSManager(app)\nmanager.callback = incoming_messages_callback\n\ntest_msg = {\n    \"key1\": \"value1\",\n    \"key2\": 2,\n    \"key3\": 3.0,\n    \"key4\": [1, 2, 3, 4],\n    \"key5\": {\"1\": 1, \"2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key6\": {\"subkey1\": \"1\", \"subkey2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key7\": None,\n}\n\n@app.task(interval=1)\nasync def publish_periodically_for_test():\n    test_msg[\"key3\"] = random.random()\n    await app.publish(\"test.subject\", test_msg)\n\n@app.http.get(\"/\")\nasync def web_endpoint_listener(request):\n\"\"\"\n    Web client to view NATS stream. Displays messages from subjects that an user is following\n\n    Example of request\n    subscribe:\n    {\"subjects\":[\"*.&gt;\"],\"action\":\"subscribe\"}\n    unsubscribe:\n    {\"subjects\":[\"*.&gt;\"],\"action\":\"unsubscribe\"}\n\n    \"\"\"\n    return web.Response(text=html, content_type=\"text/html\")\n\n@app.http.get(\"/stream\")\nasync def web_endpoint_listener(request):\n\"\"\"WebSocket connection \"\"\"\n    ws = web.WebSocketResponse()\n    await ws.prepare(request)\n    connection_id = str(uuid.uuid4())[:10]\n    await ws.send_str(json.dumps({\"success\": True, \"data\": \"Successfully connected\"}))\n    await manager.client_listener(ws, connection_id)\n    try:\n        await ws.close()\n    except Exception as e:\n        logger.error(str(e))\n    return ws\n\nasync def incoming_messages_callback(subscriber, msg, **kwargs):\n\"\"\"\n        app calls it for each new message from\n        NATS and redirects the message\n        \"\"\"\n    try:\n        await subscriber.send_str(\n            json.dumps({\"subject\": msg.subject, \"data\": msg.data})\n        )\n    except Exception as e:\n        logger.error(f\"error: {str(e)}\")\n\nif __name__ == \"__main__\":\n    app.http_server.web_app[\"subscribers\"] = {}\n    app.start()\n</code></pre> <ol> <li><code>from handler import WSSManager, html</code> imports from another module, handler.py</li> <li><code>manager = WSSManager(app)</code>  initializing of class that handles subscription/unsubscription requests from the users of the frontend</li> <li><code>manager.callback = incoming_messages_callback</code>  setting callback to incoming NATS messages</li> <li><code>test_msg</code>  - message for NATS stream</li> <li><code>@app.task(interval=1)</code>  - function under the decorator publishes messages periodically to subject \"test.subject\"</li> <li><code>@app.http.get(\"/\")</code>  - function under the decorator received HTTP request to get main web page</li> <li><code>@app.http.get(\"/stream\")</code>  - function under the decorator received HTTP request to subscribe user to NATS subject</li> <li><code>app.http_server.web_app[\"subscribers\"] = {}</code>  - This is where we store subscribers</li> </ol> <p>Let's take a look at handler.py. It includes web page and WebSocket handler</p> <p><code>handler.py</code>: <pre><code>import json\nimport copy\nfrom panini.utils.logger import get_logger\nfrom aiohttp.http_websocket import WSMsgType\n\nlogger = get_logger(None)\n\nhtml = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;NATS Bridge&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;WebSocket&lt;/h1&gt;\n        &lt;form action=\"\" onsubmit=\"sendMessage(event)\"&gt;\n            &lt;input type=\"text\" id=\"messageText\" autocomplete=\"off\"/&gt;\n            &lt;button&gt;Send&lt;/button&gt;\n        &lt;/form&gt;\n        &lt;ul id='messages'&gt;\n        &lt;/ul&gt;\n        &lt;script&gt;\n            var ws = new WebSocket(`ws://${window.location.hostname}:5001/stream`);\n            ws.onmessage = function(event) {\n                var messages = document.getElementById('messages')\n                var message = document.createElement('li')\n                var content = document.createTextNode(event.data)\n                message.appendChild(content)\n                messages.appendChild(message)\n            };\n            function sendMessage(event) {\n                var input = document.getElementById(\"messageText\")\n                ws.send(input.value)\n                input.value = ''\n                event.preventDefault()\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nclass WSSManager:\n    ssid_map = {}\n\n    def __init__(self, app):\n        self.app = app\n\n    async def client_listener(self, client_ws_connection, connection_id):\n\"\"\"app calls it for each WSS message from user\"\"\"\n        while True:\n            try:\n                msg = await client_ws_connection.receive()\n                if self.is_close_connection_message(msg):\n                    await self.close_ws_client(client_ws_connection, connection_id)\n                    return client_ws_connection\n                body = json.loads(msg.data)\n                action = self.get_action(body)\n                await self.validate_ws_message(client_ws_connection, body, action)\n                subjects = body[\"subjects\"]\n                if action == \"subscribe\":\n                    for subject in subjects:\n                        cb = await self.get_callback(client_ws_connection)\n                        await self.subscribe(subject, cb)\n                    await self.send_to_ws(\n                        client_ws_connection,\n                        success=True,\n                        message=f\"Successfully connected to events: {str(subjects)[1:-1]}\"\n                    )\n                elif action == \"unsubscribe\":\n                    for subject in subjects:\n                        await self.unsubscribe(client_ws_connection, subject)\n            except Exception as e:\n                logger.error(f\"WSS error: {str(e)} connection_id {connection_id}\")\n                try:\n                    await self.send_to_ws(\n                        client_ws_connection,\n                        success=False,\n                        message=str(e)\n                    )\n                except Exception as e:\n                    logger.error(str(e), level=\"error\")\n                return client_ws_connection\n\n    async def validate_ws_message(self, client_ws_connection, body, action):\n        if action not in [\"subscribe\", \"unsubscribe\"]:\n            message = f\"The user has to specify action in message ('subscribe' or 'unsubscribe'), got {action} instead\"\n            await self.send_to_ws(\n                client_ws_connection,\n                success=False,\n                message=message\n            )\n            raise Exception(message)\n        if \"subjects\" not in body:\n            raise Exception(\"subjects required\")\n\n    def is_close_connection_message(self, msg):\n        if msg.type == WSMsgType.CLOSE and msg.data in range(1000,1003):\n            return True\n\n    async def close_ws_client(self, client_ws_connection, conn_id):\n        connections = copy.copy(self.ssid_map)\n        for subject in connections:\n            if conn_id in self.ssid_map[subject]:\n                try:\n                    del self.ssid_map[subject][conn_id]\n                    if self.ssid_map[subject] == {}:\n                        await self.app.unsubscribe_subject(subject)\n                        del self.ssid_map[subject]\n                except Exception as e:\n                    logger.error(str(e))\n        await client_ws_connection.close()\n\n    def get_action(self, body):\n        return body[\"action\"] if \"action\" in body else \"subscribe\"\n\n    async def send_to_ws(self, client_ws_connection, success: bool, message: str):\n        message = json.dumps({\n            'success': success,\n            'message': message,\n        })\n        await client_ws_connection.send_str(message)\n\n    async def subscribe(self, subject, cb):\n        ssid = await self.app.subscribe_new_subject(subject, cb)\n        if subject not in self.ssid_map:\n            self.ssid_map[subject] = []\n        self.ssid_map[subject].append(ssid)\n\n    async def unsubscribe(self, client_ws_connection, subject):\n        if not subject in self.ssid_map:\n            await self.send_to_ws(\n                client_ws_connection,\n                success=False,\n                message=f\"The user did not subscribe to event {subject}\"\n            )\n            return\n        for ssid in self.ssid_map[subject]:\n            await self.app.unsubscribe_ssid(ssid)\n        await self.send_to_ws(\n            client_ws_connection,\n            success=True,\n            message=f\"Successfully unsubscribed from event: {subject}\"\n        )\n\n    async def get_callback(self, subscriber):\n            if hasattr(self, \"callback\"):\n                cb = self.callback\n            else:\n                raise Exception(\"self.callback function for incoming messages expected\")\n\n            async def wrapper(msg):\n                return await cb(subscriber, msg)\n            return wrapper\n</code></pre> <ol> <li><code>html</code> - web page html/js code</li> <li><code>WSSManager</code> - manage every WebSocket request with NATS subject</li> </ol> <p>That's it! Let's run our main.py and check http://127.0.0.1:5001:</p> <pre><code>&gt; python3 main.p\n======================================================================================\nPanini service connected to NATS..\nid: 5\nname: async_NATS_WSS_bridge__non_docker_env_486358__955463\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n\n======== Running on http://0.0.0.0:5001 ========\n</code></pre> <p>Then you need to follow the link http://0.0.0.0:5001 . If everything is correct you will get this page:</p> <p></p> <p>In order to subscribe to NATS subject \"test.subject\" you need to send a request in expected format:</p> <p>{\"subjects\":[\"test.subject\"],\"action\":\"subscribe\"}</p> <p>If everything is correct you should see NATS message on the web page:</p> <p></p> <p>You can also check this app below in our example here.</p>"},{"location":"0.7.2/What_is_NATS/","title":"\ud83c\udff0 What is NATS?","text":"<p>The text below is mostly taken from the official NATS docs NATS is a high-performance messaging system written in Golang. NATS is very easy to use, has very high bandwidth, and easily scales. It has 48 well-known clients, 11 of which are supported by the maintainers. NATS offers delivery guarantees, high availability, and fault tolerance. NATS is used on the web, IoT, and blockchain.</p>"},{"location":"0.7.2/What_is_NATS/#subject","title":"Subject","text":"<p>Subject in NATS is like a topic for Kafka or URL for HTTP. At its simplest, a subject is just a string of characters that form a name that publishers and subscribers can use to find each other.</p>"},{"location":"0.7.2/What_is_NATS/#subject-hierarchies","title":"Subject Hierarchies","text":"<p>For example, a world clock application might define the following to logically group related subjects:</p> <pre><code>time.us\ntime.us.east\ntime.us.east.atlanta\ntime.eu.east\ntime.eu.warsaw\n</code></pre>"},{"location":"0.7.2/What_is_NATS/#wildcards","title":"Wildcards","text":"<p>NATS provides two\u00a0wildcards\u00a0that can take the place of one or more elements in a dot-separated subject. Subscribers can use these wildcards to listen to multiple subjects with a single subscription but publishers will use a fully specified subject, without the wildcard.</p>"},{"location":"0.7.2/What_is_NATS/#matching-a-single-token","title":"Matching a single token","text":"<p>The first wildcard is\u00a0<code>*</code>\u00a0which will match a single token. For example, if an application wanted to listen for eastern time zones, they could subscribe to\u00a0<code>time.*.east</code>, which would match\u00a0<code>time.us.east</code>\u00a0and\u00a0<code>time.eu.east</code>.</p> <p></p>"},{"location":"0.7.2/What_is_NATS/#matching-multiple-tokens","title":"Matching multiple tokens","text":"<p>The second wildcard is\u00a0<code>&gt;</code>\u00a0which will match one or more tokens, and can only appear at the end of the subject. For example,\u00a0<code>time.us.&gt;</code>\u00a0will match\u00a0<code>time.us.east</code>\u00a0and\u00a0<code>time.us.east.atlanta</code>, while\u00a0<code>time.us.*</code>\u00a0would only match\u00a0<code>time.us.east</code>\u00a0since it can't match more than one token.</p> <p></p>"},{"location":"0.7.2/What_is_NATS/#monitoring-and-wire-taps","title":"Monitoring and wire taps","text":"<p>Subject to your security configuration, wildcards can be used for monitoring by creating something sometimes called a\u00a0wire tap. In the simplest case, you can create a subscriber for\u00a0<code>&gt;</code>. This application will receive all messages - again, subject to security settings - sent on your NATS cluster.</p>"},{"location":"0.7.2/What_is_NATS/#mix-wildcards","title":"Mix wildcards","text":"<p>The wildcard\u00a0<code>*</code>\u00a0can appear multiple times in the same subject. Both types can be used as well. For example,\u00a0<code>*.*.east.&gt;</code>will receive\u00a0<code>time.us.east.atlanta</code>."},{"location":"0.8.0/","title":"Panini Docs","text":"<p>\ud83d\udc4b</p> <p>Hey there!</p> <p>Welcome to Panini's explanatory documentation! Here you can become familiar with the concept, learn how to setup a working environment, and take your first steps towards building with it.</p> <p>Panini is a python microframework based on the nats.py library. Its goal is to offer developers an easy way to create NATS microservices with a lower barrier of entry. It provides a specific template for creating microservices, similarly to FastAPI, Aiohttp, or Flask. Like all of the above frameworks, Panini has its design limits and edge cases. In the event that you become restricted by Panini's capabilities, we recommend switching to nats.py.</p> <p>Panini was inspired by Faust project.</p> <p>What are microservices?</p> <p>Microservices are a type of software architecture that breaks up the features of an application into smaller, task-specific functions to make the app more resilient and scalable. More info about it here: https://microservices.io</p> <p>What can Panini do for me?</p> <p>Panini allows you to create microservices that use NATS to communicate with each other and extend the microservice by adding an HTTP server (aiohttp) to it if necessary.</p> <p>Compatibility with libraries</p> <p>Panini works well with various libraries used with FastAPI, Aiohttp, or Flask.</p> <p>Can I scale it?</p> <p>Yes, you can scale out your microservices horizontally. There are 2 strategies for distributing traffic between microservices:</p> <ul> <li>Parallel processing: Each microservice processes all messages</li> <li>Balancing: Messages are placed in a common queue and distributed among a group of microservices</li> </ul> <p>Monitoring</p> <p>Panini has a Grafana dashboard for performance monitoring; the code is here. Also, we are planning to add the ability to use Opentracing soon.</p> <p>Do you support JetStream?</p> <p>Not at the moment.</p> <p>How to start?</p> <p>We recommend getting familiar with Panini in the following order:</p> <ul> <li>Understand what NATS is about</li> <li>Install NATS and Panini</li> <li>Complete Quickstart</li> <li>Understand Panini interface and datatypes</li> <li>Explore validation and middlewares</li> <li>Try to create a Panini microservice with an HTTP server</li> <li>Test and debug</li> <li>Deploy to server</li> <li>Write your own issue and PR to make Panini better \ud83d\ude42</li> </ul>"},{"location":"0.8.0/#_1","title":"Panini Docs","text":"<p>Improved text:</p>"},{"location":"0.8.0/#panini-docks","title":"Panini Docks","text":"<p>\ud83d\udc4b </p> <p>Welcome to Panini's explanatory documentation!</p> <p>Here, you can become familiar with Panini's concept and learn how to set up a working environment, as well as take your first steps towards building with this Python microframework. Panini is based on the nats.py library and is designed to provide developers an easier way to create NATS microservices, similarly to FastAPI, Aiohttp, or Flask. However, there may be cases where you are limited by Panini's capabilities, so we suggest switching to nats.py in such cases. Panini was inspired by the Faust project.</p> <p>What are microservices?</p> <p>Microservices are a type of software architecture, which divides an application into smaller, task-specific functions to make the app more resilient and scalable. You can read more about it here.</p> <p>What can Panini do for me?</p> <p>Panini simplifies the process of creating NATS microservices, as well as adding an HTTP server (aiohttp) to it if necessary. </p> <p>Can I scale it?</p> <p>Yes, you can scale out your microservices horizontally. There are two strategies for distributing traffic between microservices:</p> <ul> <li>Parallel processing: Each microservice processes all messages</li> <li>Balancing: Messages are placed in a common queue and distributed among a group of microservices</li> </ul> <p>Monitoring</p> <p>Panini provides a Grafana dashboard for performance monitoring. You can find the code here. Additionally, we are planning to add the ability to use Opentracing soon.</p> <p>Do you support JetStream?</p> <p>Yes.</p> <p>How to start?</p> <p>We suggest getting familiar with Panini in the following order:</p> <ol> <li>Understand what NATS is about</li> <li>Install NATS and Panini</li> <li>Complete the Quickstart</li> <li>Learn about Panini's interface and datatypes</li> <li>Explore validation and middlewares</li> <li>Try creating a Panini microservice with an HTTP server</li> <li>Test and debug</li> <li>Deploy to a server</li> <li>Submit an issue or PR to make Panini better \ud83d\ude42</li> </ol> <p>If you have any questions, please don't hesitate to ask. Happy coding!</p>"},{"location":"0.8.0/Application_monitoring/","title":"Application monitoring","text":""},{"location":"0.8.0/Application_monitoring/#monitoring-system-performance-with-prometheus-grafana","title":"Monitoring System Performance with Prometheus &amp; Grafana","text":"<p>Do you want to gain more insight into the performance of your system? With Prometheus and Grafana, it's easy to monitor key metrics and get a comprehensive view of what is occurring within your system.</p> <p>We are using Prometheus, a time-series database and monitoring solution, and Grafana, a user-friendly dashboard, to collect and visualize important metrics. The Panini built-in Prometheus Monitoring Middleware is used to collect message rate by subject, request status, and request latency. After collecting, it periodically sends these metrics to the Prometheus Gateway, which is reflected directly in your Grafana dashboard.</p>"},{"location":"0.8.0/Application_monitoring/#initializing-the-monitoring","title":"Initializing the Monitoring","text":"<p>Firstly, ensure that you have Prometheus and Grafana up and running. Next, add the Prometheus Monitoring Middleware to the app:</p> <pre><code>from panini.middleware.prometheus_middleware import PrometheusMonitoringMiddleware\n\napp.add_middleware(PrometheusMonitoringMiddleware)\n# you could also specify some custom parameters (see details in middleware constructor):\n# app.add_middleware(PrometheusMonitoringMiddleware, PROMETHEUS_GATEWAY, frequency=30)\n</code></pre> <p>PrometheusMonitoringMiddleware parameters:</p> <ul> <li>pushgateway_url: str = \"localhost:9091\" - url to Prometheus PushGateway</li> <li>app = None - panini App</li> </ul> <p>When this is done, application activity will be stored in Prometheus and reflected in the Grafana dashboard.</p>"},{"location":"0.8.0/Application_monitoring/#using-grafana-prometheus","title":"Using Grafana &amp; Prometheus","text":"<p>You can use our dashboard template or create your own. To get started, check out this screenshot of the dashboard </p> <p></p> <p>To learn more about setting up Grafana &amp; Prometheus, take a look at our guide.</p>"},{"location":"0.8.0/AsyncTesting/","title":"Async Testing","text":"<p>A more advanced way to proceed with testing the Panini application. Please, proceed with simple \"Panini Testing\" for a better experience.</p> <p>Ability to run async tests is required for using <code>AsyncTestClient</code> (were tested only using pytest-async )</p>"},{"location":"0.8.0/AsyncTesting/#advantages-vs-testclient","title":"Advantages vs TestClient","text":"<ul> <li>Supports <code>&gt;</code> and <code>*</code> in subjects;</li> <li>Advanced usage of <code>await client.wait()</code>;</li> <li>Similar interface as with <code>panini.nats_client</code>;</li> <li>Separate timeout for each <code>publish</code>, <code>request</code>, <code>wait</code>;</li> <li>Additional <code>count_subject_calls</code> function.</li> </ul>"},{"location":"0.8.0/AsyncTesting/#using-asynctestclient","title":"Using AsyncTestClient","text":"<p>The process of working with <code>AsyncTestClient</code> is similar to simple <code>TestClient</code></p> <p>Import <code>AsyncTestClient</code>.</p> <p>Create an <code>AsyncTestClient</code> object using pytest.fixture (with async support) with passing to it the function that <code>runs panini</code>.</p> <p><code>AsyncTestClient</code> object <code>.start()</code> will start the panini app for testing.</p> <p>Create <code>functions</code> with a name that starts with <code>test_</code> (this is standard <code>pytest</code> conventions).</p> <p>Use <code>@pytest.mark.asyncio</code> for async support - pytest-asyncio feature.</p> <p>Use the <code>AsyncTestClient</code> object for nats communication the same way as you do with <code>panini</code> (but with some limitations)</p> <p>(The panini uses nats-io asynchronous NATS client for testing)</p> <p>Write simple <code>assert</code> statements with the standard Python expressions that you need to check (<code>pytest</code> standard).</p> <pre><code>import pytest\nfrom panini import app as panini_app\nfrom panini.async_test_client import AsyncTestClient\n\ndef run_panini():\n    app = panini_app.App(\n        service_name=\"test\",\n        host=\"127.0.0.1\",\n        port=4222\n    )\n\n    @app.listen(\"main.subject\")\n    async def main_subject(msg):\n        return {\"message\": \"Hello World!\"}\n\n    app.start()\n\n@pytest.fixture\nasync def client():\n    client = await AsyncTestClient(run_panini).start()\n    yield client\n    await client.stop()\n\n@pytest.mark.asyncio\nasync def test_main_subject(client):\n    response = await client.request(\"main.subject\", {})\n    assert response[\"message\"] == \"Hello World!\"\n</code></pre> <p>Notice that the testing functions are normal <code>async def</code>, not common <code>def</code>. And calls to the client are also using <code>await</code>. This is allowed because of <code>pytest-asyncio</code>.</p> <p>Notice that panini AsyncTestClient will run the panini app in a <code>different process</code>.  The Windows and Mac platforms have limitations for transferring objects to different processes. So we have to use <code>run_panini</code> function that will implement or import our app, and we must use <code>fixtures</code> to set up AsyncTestClient.</p>"},{"location":"0.8.0/AsyncTesting/#examples-use-cases-in-code","title":"Examples &amp; use cases in code","text":"<p>Usage of <code>client.count_subject_calls()</code> example:</p> <p><code>main.py</code></p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.listen(\"choose.table\")\nasync def choose_table(msg):\n    for table_id in range(10):\n        response = await app.request(\"check.table.is.free\", {\"table_id\": table_id})\n        if response[\"is_free\"] is True:\n            await app.publish(f\"reserve.table.{table_id}\", {})\n            return {\"success\": True, \"table_id\": table_id}\n\n    return {\"success\": False}\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p><code>test_main.py</code></p> <pre><code>import pytest\nfrom panini.async_test_client import AsyncTestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\n@pytest.fixture\nasync def client():\n    client = AsyncTestClient(run_panini)\n\n    @client.listen(\"check.table.is.free\")\n    def check_table_is_free(msg):\n        if msg.data[\"table_id\"] == 4:\n            return {\"is_free\": True}\n        return {\"is_free\": False}\n\n    @client.listen(\"reserve.table.*\")\n    def reserve_table(msg):\n        pass\n\n    await client.start()  # use after @client.listen\n    yield client\n    await client.stop()\n\n@pytest.mark.asyncio\nasync def test_choose_table(client: AsyncTestClient):\n    response = await client.request(\"choose.table\", {})\n    assert response[\"success\"] is True\n    assert response[\"table_id\"] == 4\n    assert client.count_subject_calls(\"check.table.is.free\") == 5\n    assert client.count_subject_calls(\"reserve.table.*\") == 1\n</code></pre> <p>Usage of <code>client.wait()</code>:</p> <p><code>main.py</code></p> <pre><code>import time\n\nfrom panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.task()\nasync def publish_data():\n    for _ in range(5):\n        await app.publish(\"data.1\", {\"data\": \"data1\"})\n        time.sleep(0.05)\n\n    for _ in range(5):\n        await app.publish(\"data.2\", {\"data\": \"data2\"})\n        time.sleep(0.05)\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p><code>test_main.py</code></p> <pre><code>import pytesawait client.wait(10, timeout=0.5)t\nfrom panini.async_test_client import AsyncTestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\ndata = []\n\n@pytest.fixture\nasync def client():\n    client = AsyncTestClient(run_panini)\n\n    @client.listen(\"data.*\")\n    def save_data(msg):\n        data.append(msg.data)\n\n    await client.start()\n    yield client\n    data.clear()\n    await client.stop()\n\n@pytest.mark.asyncio\nasync def test_task_publish_data_1(client: AsyncTestClient):\n    await client.wait(10, timeout=0.5)\n    assert len(data) == 10\n\n@pytest.mark.asyncio\nasync def test_task_publish_data_2(client: AsyncTestClient):\n    await client.wait(10, subject=\"data.*\")\n    assert len(data) == 10\n\n@pytest.mark.asyncio\nasync def test_task_publish_data_3(client: AsyncTestClient):\n    await client.wait(subjects={\n        \"data.1\": 5,\n        \"data.2\": 5,\n    })\n    assert len(data) == 10\n</code></pre> <p>All these 3 methods are suited to test this <code>main.py</code>, but the last one is the most concrete.</p>"},{"location":"0.8.0/Authentication/","title":"Authentication","text":"<p>Authentication is essential for any system, especially microservice architectures. Modern design approaches tend to isolate and encapsulate microservices. For the NATS world, this becomes especially critical with the release of one of the key features of NATS 2.0 - decentralized security. This feature allows creating access groups at NATS client level and at subject level. In other words, it \"containerizes\" a network, which opens up new possibilities for engineers. </p> <p>NATS offers several authentication strategies, we suggest you explore them here: https://docs.nats.io/developing-with-nats/security</p> <p>Panini does not interact with the authentication process. In fact, it just gives the interface of nats.py to establish a connection with authentication. NATS supports user-password, token, JWT, TLS, and NKeys authentication.</p> <p>Let's make an example with User-password. First, we need to run NATS broker with user-password access:</p> <pre><code>nats-server --user john --pass johnpassword\n</code></pre> <p>Then let's write a microservice that connects to NATS but without the user and the password:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"some_microservice\",\n    host=\"127.0.0.1\",\n    port=4222,\n)\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>Let's save it to a file named app.py and run it:</p> <pre><code>&gt; python3 app.py\n2021-11-04 14:58:07,163 nats.aio.client ERROR    nats: encountered error\nTraceback (most recent call last):\n  File \"*/*/*\", line 318, in connect\n    await self._process_connect_init()\n  File \"*/*/*\", line 1673, in _process_connect_init\n    raise NatsError(\"nats: \" + err_msg.rstrip('\\r\\n'))\nnats.aio.errors.NatsError: nats: 'Authorization Violation'\n</code></pre> <p>As you can see, an 'Authorization Violation' raised. There is no way to establish a connection with the NATS broker without credentials. Let's add the username and the password to our app:</p> <pre><code>from panini import app as panini_app\n\nauth = {\n    \"user\": \"john\",\n    \"password\": \"jpassword\"\n}\n\napp = panini_app.App(\n    service_name=\"some_microservice\",\n    host=\"127.0.0.1\",\n    port=4222,\n    auth=auth\n)\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>Let's run it again:</p> <pre><code>&gt; python3 app.py\n======================================================================================\nPanini service connected to NATS..\nid: 3\nname: some_microservice__non_docker_env_270377__75017\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n</code></pre> <p>It seems we have connected to the NATS broker! </p> <p>You can check out more on authentication in nats.py specs or NATS docs.</p>"},{"location":"0.8.0/Authentication/#_1","title":"Authentication","text":"<p>Authentication is an essential step for any system, especially in microservice architectures. NATS 2.X offers a decentralized security feature which allows the creation of access groups at both the NATS client and subject level. This feature provides engineers with a secure and flexible environment to work with. </p> <p>NATS supports various authentication strategies, such as user-password, token, JWT, TLS, and NKeys. In the following example, we will show how to set up a microservice to connect to NATS using a user-password authentication. </p> <p>First, we need to run NATS broker with user-password access: </p> <pre><code>nats-server --user john --pass johnpassword\n</code></pre> <p>Then let's create a microservice that connects to the NATS broker without the user and the password. We will save it to a file named app.py:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"some_microservice\",\n    host=\"127.0.0.1\",\n    port=4222,\n)\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>Let's run it:</p> <pre><code>&gt; python3 app.py\n2021-11-04 14:58:07,163 nats.aio.client ERROR    nats: encountered error\nTraceback (most recent call last):\n  File \"*/*/*\", line 318, in connect\n    await self._process_connect_init()\n  File \"*/*/*\", line 1673, in _process_connect_init\n    raise NatsError(\"nats: \" + err_msg.rstrip('\\r\\n'))\nnats.aio.errors.NatsError: nats: 'Authorization Violation'\n</code></pre> <p>An 'Authorization Violation' was raised because the NATS broker requires credentials to establish a connection. To resolve this, let's add the username and the password to our app:</p> <pre><code>from panini import app as panini_app\n\nauth = {\n    \"user\": \"john\",\n    \"password\": \"jpassword\"\n}\n\napp = panini_app.App(\n    service_name=\"some_microservice\",\n    host=\"127.0.0.1\",\n    port=4222,\n    auth=auth\n)\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>We can now run the app again:</p> <pre><code>&gt; python3 app.py\n======================================================================================\nPanini service connected to NATS..\nid: 3\nname: some_microservice__non_docker_env_270377__75017\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n</code></pre> <p>We have successfully connected to the NATS broker! </p> <p>For more information on authentication in NATS, please refer to the nats.py specs or NATS docs.</p>"},{"location":"0.8.0/Balancer/","title":"Balancer","text":"<p>Distributing traffic among multiple instances of a microservice is an important technique to ensure service reliability. NATS allows us to easily group instances of a microservice and ensure an even distribution of incoming traffic. </p> <p>By creating an App class with a <code>allocation_queue_group</code> argument upon initialization, all microservices within the group will receive messages in an even distribution. This can be done with the following code:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"async_publish\",\n    host=\"127.0.0.1\",\n    port=4222,\n    allocation_queue_group='unit1'\n)\n</code></pre> <p>The example above creates a microservice insance in the <code>unit1</code> group. This ensures that any incoming traffic will be distributed evenly among the microservices within the group.</p> <p>Here's a diagram that further illustrates the process:</p> <p></p> <p>By creating an App class with a <code>allocation_queue_group</code> argument, it's easy to ensure an even distribution of incoming traffic among microservices. This will help make sure that services stay reliable and can scale to handle more traffic.</p>"},{"location":"0.8.0/Changelog/","title":"Changelog","text":""},{"location":"0.8.0/Changelog/#v080-2022-12-20","title":"v0.8.0 (2022-12-20)","text":"<ul> <li>Parameter data_type \"json\" removed</li> <li>No need to declare \"data_type\" for \"publish\" and \"request\"</li> <li>New parameter for \u201crequest\u201d method - \u201cresponse_data_type\u201d</li> <li>Panini supports Dataclass as data_type</li> <li>Experimental: Custom data_type with Callable object</li> <li>Panini Validator has been removed</li> <li>JetStream syntax support</li> <li>Removed \"validation_error_cb\"</li> </ul>"},{"location":"0.8.0/Changelog/#v072-2022-02-14","title":"v0.7.2 (2022-02-14)","text":"<ul> <li>Fixed reconnection problem</li> </ul>"},{"location":"0.8.0/Changelog/#v070-2022-02-14","title":"v0.7.0 (2022-02-14)","text":"<ul> <li>Support NATS 2.0\ud83c\udf89. Now the panini stands on shoulders of nats-py v2.0.0</li> <li>Support Python 3.10</li> <li>Introducing on_start_task</li> <li>Introducing minimal JetStream support Since Panini switched from asyncio-nats-client to nats-py, it has become possible to support one of the most important features of NATS 2.0 - JetStream. Panini v0.7.0 does not implement an interface to JetStream at the framework level. Instead, it is suggested to use directly nats-py.</li> </ul>"},{"location":"0.8.0/Changelog/#v062-2021-11-11","title":"v0.6.2 (2021-11-11)","text":"<ul> <li>Fixed bug: tasks doesn't works with HTTP server</li> <li>Fixed package incompatibility</li> </ul>"},{"location":"0.8.0/Changelog/#v062-2021-11-11_1","title":"v0.6.2 (2021-11-11)","text":"<ul> <li>Fixed bug: tasks doesn't works with HTTP server</li> <li>Fixed package incompatibility</li> </ul>"},{"location":"0.8.0/Changelog/#v060-2021-11-04","title":"v0.6.0 (2021-11-04)","text":"<ul> <li>Global refactoring</li> <li>Added new interface for pereodic tasks: <code>@app.task(interval=1)</code></li> <li>Changed <code>listen_subject_only_if_include</code> param in App to function <code>app.add_filters(include, exclude)</code></li> <li>Added ability to use all authorization methods from nats.py</li> <li>Added ability to establish connection to multiple NATS brokers</li> <li>Added start message when starting in terminal</li> </ul>"},{"location":"0.8.0/Changelog/#v052-2021-08-17","title":"v0.5.2 (2021-08-17)","text":"<ul> <li>Added ability to use any parameters for aiohttp including ssl_context(for HTTPS)</li> </ul>"},{"location":"0.8.0/Changelog/#v050-2021-07-21","title":"v0.5.0 (2021-07-21)","text":"<ul> <li>Implemented AsyncTestClient for better testing experience</li> <li>Added listen_subject_only_if_exclude parameter for excluding unnecessary subjects</li> </ul>"},{"location":"0.8.0/Changelog/#v040-2021-07-09","title":"v0.4.0 (2021-07-09)","text":"<ul> <li>Fixed silent error if response type is list</li> <li>Fixed TestClient</li> <li>Added non-blocking request support for bytes messages</li> <li>Added automatically generated changelog</li> <li>Added pending_bytes_limit parameter to panini App for nats_client</li> <li>Added is_async parameter to subscribe_new_subject for nats_client</li> <li>Added data types for dynamic subscription</li> <li>Added test for long requests</li> </ul>"},{"location":"0.8.0/Changelog/#v031-2021-05-25","title":"v0.3.1 (2021-05-25)","text":"<ul> <li>Fixed bug with no hinting for publish &amp; request functions</li> <li>Removed 'app_strategy' parameter</li> <li>Removed old 'aio' interface for nats_client &amp; managers</li> <li>Added auto unsubscribe to test_client waiting for panini to start</li> <li>Change ci test flow, add test on python v3.9-major fixes in TestClient, changes in client.wait() function</li> <li>Added non-blocking request support for bytes messages</li> </ul>"},{"location":"0.8.0/Changelog/#v030-2021-04-27","title":"v0.3.0 (2021-04-27)","text":"<ul> <li>removed sync app connection strategy</li> <li>removed redis dependency</li> <li>minor fix</li> </ul>"},{"location":"0.8.0/Changelog/#v023-2021-04-06","title":"v0.2.3 (2021-04-06)","text":"<ul> <li>Added CI/CD checks</li> <li>Moved from json to ujson</li> <li>Fixed logging bugs</li> <li>Fixed bug with emulator for windows</li> <li>Many minor bugs</li> </ul>"},{"location":"0.8.0/Changelog/#v022-2021-03-24","title":"v0.2.2 (2021-03-24)","text":"<ul> <li>Added Emulator middlewares: ReaderEmulatorMiddleware &amp; WriterEmulatorMiddleware</li> <li>Fixed Test client</li> <li>Minor fix: grafana dashboard default rate size changed from 1m to 15m PrometheusMonitoringMiddleware(ex ListenPerformancePrometheusTracerMiddleware)</li> </ul>"},{"location":"0.8.0/Changelog/#v020-2021-03-12","title":"v0.2.0 (2021-03-12)","text":"<ul> <li>Msg object instead of arguments subject and message in listener's callbacks</li> <li>Addition datatypes supported: bytes, str</li> <li>Added publish/request from another thread</li> <li>Added http-like middlewares</li> <li>Added default middleware that calculates processing time for incoming messages and sends it to pushgateway(prometheus)</li> <li>Added default middleware that sends alert message to some topic if service for NatsTimeoutError</li> <li>Changed default console logging level: WARNING -&gt; INFO</li> <li>Added new examples</li> </ul>"},{"location":"0.8.0/Data_Serialization/","title":"Data Serialization","text":"<p>Note: Since Panini v0.8.0 internal validator has been removed, if you need incoming message validation, we recommend using dataclasses.</p> <p>Ensuring reliable communication between microservices is crucial for a system's reliability. To help with this, Panini v0.8.0 introduced dataclasses as a way to validate incoming messages. </p> <p>Panini uses dataclasses to check all fields and data types of values for incoming JSON messages. We\u2019ve tested it mostly with Pydantic dataclasses and also with Mashumaro.</p> <p>To illustrate this, here is an example of a Panini application with dataclasses used to serialize incoming messages:</p> <pre><code>import asyncio\nfrom panini import app as panini_app\nfrom pydantic import BaseModel\n\npapp = panini_app.App(\n    service_name=\"serializers\",\n    host=\"127.0.0.1\",\n    port=4222,\n)\n\nlog = papp.logger\n\n\nclass SubTestData(BaseModel):\n    subkey1: str\n    subkey2: int\n\nclass TestMessage(BaseModel):\n    key1: str\n    key2: int\n    key3: float\n    key4: list\n    key5: dict\n    key6: SubTestData\n    key7: int = None\n    key8: int = None\n\n\nmessage = {\n    \"key1\": \"value1\",\n    \"key2\": 2,\n    \"key3\": 3.0,\n    \"key4\": [1, 2, 3, 4],\n    \"key5\": {\"1\": 1, \"2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key6\": {\"subkey1\": \"1\", \"subkey2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key7\": None,\n}\n\n@papp.task()\nasync def publish_dataclass():\n    for _ in range(10):\n        message_dataclass = TestMessage(**message)\n        await papp.publish(\n            subject=\"some.publish.subject\",\n            message=message_dataclass\n        )\n\n@papp.listen(\"some.publish.subject\", data_type=TestMessage)\nasync def receive_dataclass(msg):\n    log.info(f\"got message {msg.data}\")\n    await asyncio.sleep(1)\n\n\nif __name__ == \"__main__\":\n    papp.start()\n</code></pre> <p>For more information, read the Pydantic validation documentation.</p>"},{"location":"0.8.0/Data_Serialization/#experimental-custom-incoming-message-serialization","title":"Experimental: Custom incoming message serialization","text":"<p>Panini also supports any Callable object as a <code>data_type</code> for custom processing. Here is an example of how to use it:</p> <pre><code>from panini.exceptions import MessageSchemaError\nfrom panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test_serializer_callable\",\n    host=\"127.0.0.1\",\n    port=4222,\n)\n\n\ndef callable_validator(message):\n    if type(message) is not dict:\n        raise MessageSchemaError(\"type(data) is not dict\")\n    if \"data\" not in message:\n        raise MessageSchemaError(\"'data' not in message\")\n    if type(message[\"data\"]) is not int:\n        raise MessageSchemaError(\"type(message['data']) is not int\")\n    if message[\"data\"] &lt; 0:\n        raise MessageSchemaError(f\"Value of field 'data' is {message['data']} that negative\")\n    message[\"data\"] += 1\n    return message\n\n\n@app.listen(\"test_validator.foo\", data_type=callable_validator)\nasync def publish(msg):\n    return {\"success\": True}\n\n\n@app.listen(\"test_validator.foo-with-error-cb\", data_type=callable_validator)\nasync def publish(msg):\n    return {\"success\": True}\n\n\n@app.listen(\"test_validator.check\")\nasync def check(msg):\n    try:\n        message = callable_validator(**msg.data)\n    except MessageSchemaError:\n        return {\"success\": False}\n\n    return {\"success\": True}\n\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>Using a custom data_type to process messages is an experimental feature, so please use it with caution.</p>"},{"location":"0.8.0/Datatypes/","title":"Datatypes","text":""},{"location":"0.8.0/Datatypes/#working-with-data-types-in-panini","title":"Working with Data Types in Panini","text":"<p>Panini allows you to work with various data types when sending and receiving messages. This can be beneficial in a microservice architecture, as you can use the right format for the task at hand. Panini supports the following data types:</p> <ul> <li>JSON </li> <li>Dict (based on JSON) - default data type</li> <li>Dataclass (based on JSON)</li> <li>String</li> <li>Bytes</li> </ul> <p>To set a specific data type, you need to set it as an argument <code>data_type</code> when sending or listening for messages. </p> <p>For example, to send a message in String format, use the following code:</p> <pre><code>await app.publish(\n          subject=\"some.data.in.string\",\n          message=\"This is a string message\",\n          data_type=str,\n      )\n</code></pre> <p>Or, to listen for incoming Bytes, use the following code:</p> <pre><code>@app.listen(\"some.data.in.bytes\", data_type=bytes)\nasync def receive_bytes(msg):\n    log.info(f\"got subject {msg.subject}\")\n    log.info(f\"got message {msg.data}\")\n</code></pre> <p>You can also specify the <code>data_type</code> of the response from a request. For example:</p> <pre><code>subject = \"a.b.c\"\nmessage = {\"param1\": \"value1\"}\u2028\n\u2028response: bytes = app.request(subject=subject, message=message, response_data_type=bytes)\u2028\n</code></pre> <p>The result should be returned as bytes, otherwise, Panini will raise an exception.</p>"},{"location":"0.8.0/Datatypes/#one-more-example","title":"One more example","text":"<p>JSON type transforms to Python's dict inside an endpoint's function. In this case, all elements of your dict should be capable of jsonfying in order to send a response.</p> <p>Let's take a look at an example that includes a task that sends a message and 3 listeners that receive this message as different data types:</p> <pre><code>import json\nfrom panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='quickstart-app',\n        host='127.0.0.1',\n        port=4222,\n)\n\nmessage = {\n    \"key4\": \"value1\",\n    \"key7\": 2,\n    \"key3\": 3.024444412342342342,\n    \"key1\": [1, 2, 3, 4],\n    \"key6\": {\"1\": 1, \"2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key5\": {\"subkey1\": \"1\", \"subkey2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key2\": None,\n}\n\n@app.task(interval=1)\nasync def publish_string():\n    some_string = json.dumps(message, sort_keys=True)\n    for _ in range(10):\n        await app.publish(\n            subject=\"some.publish.subject\", \n            message=some_string, \n            data_type=str,\n        )\n\n@app.listen(\"some.publish.subject\")\nasync def receive_dict(msg):\n    log.info(f\"got subject {msg.subject}\")\n    log.info(f\"got message {msg.data} type: {type(msg.data)}\")\n\n@app.listen(\"some.publish.subject\", data_type=str)\nasync def receive_string(msg):\n    log.info(f\"got subject {msg.subject}\")\n    log.info(f\"got message {msg.data} type: {type(msg.data)}\")\n\n@app.listen(\"some.publish.subject\", data_type=bytes)\nasync def receive_bytes(msg):\n    log.info(f\"got subject {msg.subject}\")\n    log.info(f\"got message {msg.data} type: {type(msg.data)}\")\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>Explanation of the code:</p> <ol> <li>The message template is a dict which can be transformed into JSON</li> <li><code>@app.task</code> publishes data in string format to the subject <code>\"some.publish.subject\"</code> (jsonified data is a string)</li> <li>The first <code>@app.listen</code> receives this data as the default data type, transforming it into a dict</li> <li>The second <code>@app.listen</code> receives the same data as a string</li> <li>The third <code>@app.listen</code> receives the same data as bytes</li> </ol> <p>\ud83d\udca1</p><p> All these data types are just representations at the Panini level. Eventually, Panini transforms data into bytes before sending it to NATS for any data type. When another microservice receives this message, it also receives bytes which are then transformed into the requested data type in the endpoint function.</p> <p>String type is a string only inside the endpoint's function. Eventually, a microservice sends bytes anyway.</p> <p>For an example of how to use Dataclasses, see Data Serialization page.</p>"},{"location":"0.8.0/Deployment/","title":"Deployment","text":"<p>\ud83d\udee0</p><p> This page is under construction</p>"},{"location":"0.8.0/Distributed_tracing/","title":"Distributed tracing","text":"<p>The tracing feature will be released as soon as the nats.py on which Panini is based releases the ability to use headers in NATS messages. Panini will provide tools for Opentracing:</p> <ul> <li>middleware for automatic tracing</li> <li>an interface to manage tracing manually.</li> </ul> <p>\ud83d\udee0</p><p> This page is under construction</p>"},{"location":"0.8.0/Emulator/","title":"Emulator","text":"<p>This feature is currently being tested. The main idea is very simple: If the service breaks down, the developer can \u201croll back time\u201d by N milliseconds and reproduce all messages that come to the microservice in debug mode.</p> <p>\ud83d\udee0</p><p> This page is under construction</p>"},{"location":"0.8.0/Examples/","title":"Examples","text":"<p>Simple examples</p> <p>Panini+PostgreSQL</p> <p>1 million requests</p>"},{"location":"0.8.0/HTTP_server/","title":"HTTP server","text":"<p>In some cases, a NATS network is not enough for a microservice's requirements and engineers may need an HTTP web server within the microservice to create a gateway between HTTP and NATS spaces. To accomplish this, Panini uses Aiohttp.</p> <p>In order to run a HTTP server, you have to call <code>app.setup_web_server</code> with host, port, and other parameters, such as <code>ssl_context</code>, <code>shutdown_timeout</code>, or <code>access_log</code>. A sample microservice with an HTTP endpoint might look like this:</p> <pre><code>from aiohttp import web\nfrom panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='nats-microservice-that-also-http',\n        host='127.0.0.1',\n        port=4222,\n)\napp.setup_web_server(port=5000)\n\n# NATS listeners &amp; tasks\n\n@app.http.get(\"/test\")\nasync def web_endpoint_listener(request):\n\"\"\"\n    Single HTTP endpoint\n    \"\"\"\n    return web.Response(text=\"Hello, HTTP world\")\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>This uses <code>@app.http.get</code> for HTTP. Panini uses Aiohttp under the hood, which means <code>@app.http</code> is the same as <code>routes</code> from Aiohttp. For example, the following code is the same:</p> <pre><code>routes = web.RouteTableDef()\n\n@routes.get('/get')\nasync def handle_get(request):\n    ...\n\n@routes.post('/post')\nasync def handle_post(request):\n    ...\n\napp.router.add_routes(routes)\n</code></pre> <p>is equal to:</p> <pre><code>@app.http.get('/get')\nasync def handle_get(request):\n    ...\n\n@app.http.post('/post')\nasync def handle_post(request):\n    ...\n\n# no need to call 'app.router.add_routes(routes)'\n</code></pre> <p>Now, let's look at an example of how to build a little REST API in Panini:</p> <pre><code>from aiohttp import web\nfrom panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='nats-microservice-that-also-http-rest',\n        host='127.0.0.1',\n        port=4222,\n)\napp.setup_web_server(port=5000)\n\n@app.timer_task(interval=2)  \nasync def publish():\n    for _ in range(10):\n        await app.publish(subject=\"some.publish.subject\", message={'some':'message'})\n\n@app.http.view(\"/path/to/rest/endpoints\")\nclass MyView(web.View):\n\"\"\"\n    HTTP endpoints for REST schema\n    \"\"\"\n\n    async def get(self):\n        # request = self.request\n        return web.Response(text=\"Hello, REST world\")\n\n    async def post(self):\n        # request = self.request\n        return web.Response(text=\"Hello, REST world\")\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>This example demonstrates how to build a class-based view from Aiohttp. To learn more, we recommend checking its documentation: https://docs.aiohttp.org/en/stable/web_quickstart.html#resource-views.</p> <p>Finally, let's move on to WebSocket servers.</p>"},{"location":"0.8.0/How_Panini_works/","title":"How Panini works","text":"<p>If this is your first time here, we recommended installing NATS and going through the quick start before exploring these sections. The current section describes the main components, their parameters, and their attributes:</p> <p>Panini app arguments</p> <p>Panini app functions</p> <p>Incoming message structure</p> <p>How to validate that microservice connected to NATS</p>"},{"location":"0.8.0/How_to_contribute/","title":"How to contribute","text":""},{"location":"0.8.0/How_to_contribute/#welcome-contributor","title":"Welcome contributor!","text":"<p>First off, thank you for considering contributing to Panini. We are looking for developers to make Panini a great project.</p>"},{"location":"0.8.0/How_to_contribute/#why-you-need-to-read-our-guidelines","title":"Why you need to read our guidelines.","text":"<p>Following these guidelines ensures that you respect the time of the developers managing and developing this open-source project. In return, they reciprocate that respect in addressing your issue, assessing changes, and helping you finalize your pull requests.</p>"},{"location":"0.8.0/How_to_contribute/#your-first-contribution","title":"Your First Contribution","text":"<p>Working on your first Pull Request? You can learn how from this\u00a0free\u00a0series,\u00a0How to Contribute to an Open Source Project on GitHub.</p> <p>Well, how can you help:</p> <ul> <li>suggest new updates\u00a0here</li> <li>review a\u00a0pull request</li> <li>fix an\u00a0issue</li> <li>write a tutorial</li> <li>always follow\u00a0this\u00a0guide for your contributions</li> </ul> <p>At this point, you're ready to make your changes! Feel free to ask for help; everyone is a beginner at first\u00a0\ud83d\ude38</p>"},{"location":"0.8.0/Incoming_Message_Structure/","title":"Incoming Message Structure","text":"<p>The @app.listen decorator is used to create a listener for messages sent to the specified NATS subject.</p> <pre><code>@app.listen(subject='some.subject')\nasync def subject_for_requests_listener(msg):\n    subject = msg.subject\n    message = msg.data\n    # handle incoming message\n</code></pre> <p>When a message is received, the <code>msg</code> object is passed to the callback function. This object contains the following properties:</p> <ul> <li>msg.subject (str): The NATS subject that the message was sent from.</li> <li>msg.data (dict or str or bytes): Analogue of the body of an HTTP message.</li> <li>msg.reply (str): A one-time use subject to send a response.</li> <li>msg.sid (str): The subscribe ID that the message was sent from.</li> <li>msg.headers (dict): A dictionary containing any custom headers set externally.</li> </ul>"},{"location":"0.8.0/Install/","title":"Install","text":""},{"location":"0.8.0/Install/#prerequisites","title":"Prerequisites","text":"<p>Before getting started, you need to have the following prerequisites installed: - Python (3.8 or higher)  - pip - NATS - Docker (optional) </p>"},{"location":"0.8.0/Install/#installing-nats","title":"Installing NATS","text":"<p>NATS should be installed as per the documentation instructions. Here are some of the ways to do so:</p> <ul> <li>Using Docker:    <pre><code>&gt; docker pull nats:latest\n</code></pre></li> <li>On Windows:    <pre><code>&gt; choco install nats-server\n</code></pre></li> <li>On Mac OS:    <pre><code>&gt; brew install nats-server\n</code></pre></li> </ul>"},{"location":"0.8.0/Install/#running-nats","title":"Running NATS","text":"<p>Once NATS is installed, you need to run the server. Simply execute the following command:</p> <pre><code>&gt; nats-server\n[1281] 2021/11/01 07:19:20.762736 [INF] Starting nats-server version 2.1.6\n[1281] 2021/11/01 07:19:20.762853 [INF] Git commit [not set]\n[1281] 2021/11/01 07:19:20.763182 [INF] Listening for client connections on 0.0.0.0:4222\n[1281] 2021/11/01 07:19:20.763190 [INF] Server id is NBIDLI72N7ONJZSSFKLL774A7RWCKVHU26X2QI7RFOETJFURXA6CETRB\n[1281] 2021/11/01 07:19:20.763192 [INF] Server is ready\n</code></pre>"},{"location":"0.8.0/Install/#installing-panini","title":"Installing Panini","text":"<p>You can install Panini using the <code>pip</code> package manager or from the GitHub repository. </p> <ul> <li> <p>Using pip:   <pre><code>&gt; pip install panini\n</code></pre></p> </li> <li> <p>Using GitHub:   <pre><code>&gt; git clone https://github.com/lwinterface/panini.git\n</code></pre></p> </li> </ul> <p>After installation, verify that Panini has been installed by running this command:</p> <pre><code>&gt; pip show panini\nName: panini\nVersion: 0.8.0\nSummary: A python messaging framework for microservices based on NATS\nHome-page: https://github.com/lwinterface/panini\nAuthor: Op Return SA, developers: Andrii Volotskov, Danylo Tiutiushkin\nAuthor-email: example@example.com\nLicense: MIT\nLocation: /Users/artas/ITProduction/Pierre/panini/venv310/lib/python3.10/site-packages\nRequires: python-json-logger, nest-asyncio, ujson, nats-py\nRequired-by:\n</code></pre>"},{"location":"0.8.0/JetStream/","title":"JetStream","text":"<p>Since Panini switched from asyncio-nats-client to nats-py, it has become possible to support one of the most important features of NATS 2.0 - JetStream.</p> <p>The major difference between Core NATS and NATS JetStream is that Core NATS is a stateless messaging protocol, meaning that it does not guarantee message delivery, while JetStream is an extension of Core NATS that allows you to store messages and replay in case of problems.</p> <p>It is recommended to familiarize yourself with JetStream by reading the NATS Concepts documentation. Additionally, you can read the Grokking NATS Consumers blog post for more information.</p> <p>Now, let's look at an example of a JetStream publisher microservice.</p> <p><pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"js_publish\",\n    host=\"127.0.0.1\",\n    port=4222,\n    enable_js=True\n)\n\nlog = app.logger\nNUM = 0\nTEST_STREAM = \"test_stream\"\nSTREAM_SUBJECTS = [\n    \"some.js.subject\",\n]\n\n@app.on_start_task()\nasync def on_start_task():\n    await app.js.add_stream(name=TEST_STREAM, subjects=STREAM_SUBJECTS)\n    await app.js.add_consumer(stream=TEST_STREAM, durable_name=TEST_STREAM)\n\ndef get_message():\n    return {\n        \"id\": app.nats.client.client_id,\n    }\n\n\n@app.timer_task(interval=2)\nasync def publish_periodically():\n    subject = \"test.app2.stream\"\n    message = get_message()\n    global NUM\n    NUM+=1\n    message['counter'] = NUM\n    await app.publish(subject=subject, message=message)\n    log.info(f\"sent {message}\")\n\n\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> In the example above, we create a Stream using <code>on_start_task()</code> to make sure the Stream is created before we start sending messages. Additionally, you have to use the flag <code>enable_js=True</code> when initializing a panini app.</p> <p>Now, let's look at an example of a JetStream push-based consumer microservice.</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"js_listen_push\",\n    host=\"127.0.0.1\",\n    port=4222,\n    enable_js=True\n)\n\nlog = app.logger\nNUM = 0\n\n@app.task()\nasync def subscribe_to_js_stream_push():\n    async def cb(msg):\n        log.info(f\"got JS message ! {msg.subject}:{msg.data}\")\n\n    await app.nats.js_client.subscribe(\"test.*.stream\", cb=cb, durable='consumer-1', stream=\"sample-stream-1\")\n\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>Finally, here is an example of a JetStream pull-based consumer microservice.</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"js_listen_pull\",\n    host=\"127.0.0.1\",\n    port=4222,\n    enable_js=True\n)\n\nlog = app.logger\nNUM = 0\n\ndef get_message():\n    return {\n        \"id\": app.nats.client.client_id,\n    }\n\n\n@app.on_start_task()\nasync def create_js_staff():\n    await app.js.add_stream(name=TEST_STREAM, subjects=STREAM_SUBJECTS)\n    await app.js.add_consumer(stream=TEST_STREAM, durable_name=TEST_STREAM, deliver_group='ABC')\n\n@app.task()\nasync def subscribe_to_js_stream_pull():\n    psub = await app.nats.js.pull_subscribe(STREAM_SUBJECTS[0], durable=TEST_STREAM)\n    # Fetch and ack messages from consumer.\n    for i in range(0, 10):\n        msgs = await psub.fetch(1)\n        for msg in msgs:\n            print(msg.data)\n            await msg.ack()\n\n@app.task(interval=1)\nasync def subscribe_to_js_stream_pull():\n    print('some parallel task')\n\n\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>At the time of writing, Panini (v0.8.0) does not support key-value storage and other JetStream features. However, with each new version, more features and functionalities are added. Additionally, you can use the <code>app.nats</code> object to access the underlying nats.py Client object.</p>"},{"location":"0.8.0/License/","title":"License","text":""},{"location":"0.8.0/License/#mit-license","title":"MIT License","text":"<p>Copyright \u00a9 2021 lwinterface</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"0.8.0/Logger/","title":"What is the Panini Internal Logger?","text":"<p>The Panini internal logger is a default Python logger with some settings that the Panini team found convenient. If you are using your own logging style, you can skip this section.</p> <p>The logger has two important parameters:</p> <ul> <li>logger_files_path - the path to the log folder - it can be absolute or relative (relating to the app root path). For example:</li> </ul> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name='logger_example',\n    host='127.0.0.1',\n    port=4222,\n    logger_files_path='some/relative/path',  # put here absolute or relative path\n)\n\nlog = app.logger\n\nlog.info(\"some log\")  # write log\n</code></pre> <ul> <li>in_separate_process - this parameter specifies whether you want the logger to run in a separate process or not. By default it is set to <code>False</code> which is more intuitive, but if you need more efficient logging, it can be set to <code>True</code>:</li> </ul> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name='logger_example',\n    host='127.0.0.1',\n    port=4222,\n    logger_in_separate_process=False,  # by default, more intuitive\n    # logger_in_separate_process=True  # more efficient, but needs good understanding of process\n)\n\nlog = app.logger\n\nlog.info(\"some log\")  # write log\n</code></pre>"},{"location":"0.8.0/Logger/#log-config","title":"Log Config","text":"<p>The logger uses a simple default config that fits most logger needs:</p> <pre><code>`{\n\"version\": 1,\n// we use False for handling build in errors in our logs\n\"disable_existing_loggers\": false,\n\"formatters\": {\n\"detailed\": {\n\"class\": \"pythonjsonlogger.jsonlogger.JsonFormatter\",\n// notice 'extra' field - that's for extra arguments logging\n\"format\": \"%(created)f %(name)s %(levelname)s %(processName)s %(threadName)s %(message)s %(extra)s\"\n},\n\"simple\": {\n\"class\": \"logging.Formatter\",\n\"format\": \"%(asctime)s %(name)-15s %(levelname)-8s %(message)s\"\n}\n},\n\"handlers\": {\n\"console\": {\n\"class\": \"logging.StreamHandler\",\n\"level\": \"INFO\",\n\"formatter\": \"simple\",\n\"stream\": \"ext://sys.stdout\"\n},\n\"panini\": {\n\"level\": \"DEBUG\",\n\"class\": \"logging.handlers.RotatingFileHandler\",\n\"filename\": \"panini.log\",\n\"mode\": \"a\",\n\"formatter\": \"detailed\",\n\"maxBytes\": 1000000,\n\"backupCount\": 10,\n},\n\"inter_services_request\": {\n\"level\": \"DEBUG\",\n\"class\": \"logging.handlers.RotatingFileHandler\",\n\"filename\": \"inter_services_request.log\",\n\"mode\": \"a\",\n\"formatter\": \"detailed\",\n\"maxBytes\": 1000000,\n\"backupCount\": 10,\n},\n// root logger, that contains all existing logs\n\"app\": {\n\"level\": \"DEBUG\",\n\"class\": \"logging.handlers.RotatingFileHandler\",\n\"filename\": \"app.log\",\n\"mode\": \"a\",\n\"formatter\": \"detailed\",\n\"maxBytes\": 1000000,\n\"backupCount\": 10,\n},\n\"errors\": {\n\"class\": \"logging.FileHandler\",\n\"filename\": \"errors.log\",\n\"mode\": \"a\",\n\"level\": \"ERROR\",\n\"formatter\": \"detailed\"\n},\n// consider your app.name here\n\"app_name\": {\n\"level\": \"DEBUG\",\n\"class\": \"logging.handlers.RotatingFileHandler\",\n// and here also\n\"filename\": \"app_name.log\",\n\"mode\": \"a\",\n\"formatter\": \"detailed\",\n\"maxBytes\": 1000000,\n\"backupCount\": 10,\n}\n},\n\"loggers\": {\n\"panini\": {\n\"handlers\": [\n\"panini\"\n]\n},\n\"inter_services_request\": {\n\"handlers\": [\n\"inter_services_request\"\n]\n},\n// your app_name is here\n\"app_name\": {\n\"handlers\": [\n\"app_name\"\n]\n},\n},\n\"root\": {\n\"level\": \"DEBUG\",\n\"handlers\": [\n\"console\",\n\"errors\",\n\"app\"\n]\n}\n}`\n</code></pre> <p>If you need advanced logging, you can provide a custom log configuration. To do that, create a <code>config/log_config.json</code> file inside your app root path. (See log_config.json.sample for an example.)</p> <p>Please note that some formatters and loggers will be added to your custom config, but not overwritten if they exist.</p> <p>You can also provide some keywords to the custom log config file that will be replaced by some meaningful data. These keywords are <code>%MS_NAME%</code>, which will be replaced with the microservice name (app_name), <code>%CLIENT_ID%</code>, which will be replaced with the client_id from os.environ (advanced), and <code>%DATETIME%</code>, which will be replaced with the datetime of the app start in a human-readable string format.</p> <p>Note that these keywords only work inside the \"filename\" log configuration.</p>"},{"location":"0.8.0/Logger/#additional-logger-settings","title":"Additional Logger Settings","text":"<p>If you want to be able to log some extra parameters, you can do this by using the <code>get_logger</code> utility:</p> <pre><code>from panini.utils.logger import get_logger\n\nlog = get_logger('app')\n\nlog.warning('some log', extra_parameter='some extra parameter')\n</code></pre> <p>These extra parameters will be logged with each log - see %(extra)s argument in the default configuration format.</p> <p>Note that extra parameters will be added to your logs only if you add \"%(extra)s\" to your log config formatter.</p>"},{"location":"0.8.0/Middlewares/","title":"Middlewares","text":"<p>A \"*middleware\"* (in common meaning) is a function that works with every request before it is processed by a message handler. And also with every response before returning it. </p> <p>Panini middleware works similar to Django or Flask-like frameworks, and also offers to use middleware for sending messages. </p> <p>Example of an app with such middleware:</p> <pre><code>import time\nfrom panini import app as panini_app\nfrom panini.middleware import Middleware\n\napp = panini_app.App(\n    service_name=\"another_panini_app\",\n    host=\"127.0.0.1\",\n    port=4222,\n)\n\nclass ProcessTimeMiddleware(Middleware):\n    async def send_request(self, subject: str, message, request_func, *args, **kwargs):\n\"\"\"\n        measure request processing time and add to a response\n        \"\"\"\n        start_time = time.time()\n        response = await request_func(subject, message, *args, **kwargs)\n        process_time = time.time() - start_time\n        response[\"process-time\"] = str(process_time)\n        return response\n\n@app.task(interval=1)\nasync def publish_periodically():\n    message = {\"request_type\":\"Bitcoin price\"}\n    result = await app.request(subject=\"some.request.subject\", message=message)\n    # received response: {\"bitcoin-price\": 100000, \"process-time\": '0.0051320'}\n    print(f\"requested Bitcoin price, result: {result}\")\n\n@app.listen(\"some.publish.subject\")\nasync def receive_messages(msg):\n    print(\"received request for Bitcoin price\")\n    bitcoin_price = 100000\n    # response to send: {\"bitcoin-price\": 100000}\n    return {\"bitcoin-price\": bitcoin_price}\n\nif __name__ == \"__main__\":\n    app.add_middleware(ProcessTimeMiddleware)\n    app.start()\n</code></pre> <p>As you can see <code>ProcessTimeMiddleware</code> measures the request time and adds it to the response in the <code>process-time</code> field.</p> <p>Of course, in real tasks, the listener will be in another microservice. We put the task and the listener in one microservice to simplify this example.</p>"},{"location":"0.8.0/Middlewares/#middleware-in-detail","title":"Middleware in Detail","text":"<p>Panini has two core operations for communication between microservices: send and listen. Using Panini Middleware, you can apply modifications to both of these operations before and after they are called.</p> <p>How it works:</p> <ol> <li>It takes each operation in your application.</li> <li>It can then do something to that operation or run any needed code (before the operation is called).</li> <li>It passes the operation to be processed by the rest of the application.</li> <li>It then takes the response generated by the application.</li> <li>It can do something to that response or run any needed code (after an operation is called).</li> <li>It returns the response.</li> </ol>"},{"location":"0.8.0/Middlewares/#middleware-interface","title":"Middleware Interface","text":"<p>The basic interface of Panini Middleware looks like this:</p> <pre><code>class Middleware:\n        def __init__(self, *args, **kwargs):\n        pass\n\n    async def send_publish(self, subject: str, message, publish_func, *args, **kwargs):\n\"\"\"\n        :param subject: str\n        :param message: any of supported types\n        :param publish_func: Callable for publish\n        :return: None\n        \"\"\"\n\n    async def listen_publish(self, msg, callback):\n\"\"\"\n        :param msg: Msg\n        :param callback: Callable, that will be called on receive message\n        :return: None\n        \"\"\"\n\n    async def send_request(self, subject: str, message, request_func, *args, **kwargs):\n\"\"\"\n        :param subject: str\n        :param message: any of supported types\n        :param request_func: Callable for request\n        :return: any of supported types\n        \"\"\"\n\n    async def listen_request(self, msg, callback):\n\"\"\"\n        :param msg: Msg\n        :param callback: Callable, that will be called on receive message\n        :return: any of supported types\n        \"\"\"\n\n        # and composed functions for better user experience:\n        async def send_any(self, subject: str, message, send_func, *args, **kwargs):\n\"\"\"\n        :param subject: str\n        :param message: any of supported types\n        :param send_func: Callable for send\n        :return: None or any of supported types\n        \"\"\"\n\n    async def listen_any(self, msg, callback):\n\"\"\"\n        :param msg: Msg\n        :param callback: Callable, that will be called on receive message\n        :return: None or any of supported types\n        \"\"\"\n</code></pre> <p>Note that <code>send_any</code> will do the job for <code>send_request</code> and <code>send_publish</code>, if they are not implemented, but won't override them if they exist. The same applies for <code>listen_any</code>.</p>"},{"location":"0.8.0/Middlewares/#examples","title":"Examples","text":""},{"location":"0.8.0/Middlewares/#processtimemiddleware","title":"ProcessTimeMiddleware","text":"<p>Let's look at the first example in this section. This middleware adds a <code>process-time</code> parameter to the response. The <code>process-time</code> parameter contains the time in seconds it takes to send and process the request. The <code>send_request</code> function receives:</p> <ul> <li>The <code>subject</code> and <code>message</code>, as in a common request function.</li> <li>A function <code>request_func</code> that receives the subject, message, and args/kwargs.<ul> <li>This function sends a request to the corresponding subject with the provided message.</li> <li>This function also calls any other middlewares (if they exist) inside the app.</li> <li>Then, it returns the response before returning it.</li> </ul> </li> <li>You can further modify the response before returning it.</li> </ul> <pre><code>import time\n\nfrom panini.middleware import Middleware\n\nclass ProcessTimeMiddleware(Middleware):\n    async def send_request(self, subject: str, message, request_func, *args, **kwargs):\n        start_time = time.time()\n        response = await request_func(subject, message, *args, **kwargs)\n        process_time = time.time() - start_time\n        response[\"process-time\"] = str(process_time)\n        return response\n</code></pre> <p>To register the middleware, add ProcessTimeMiddleware before <code>app.start()</code>:</p> <pre><code>app.add_middleware(ProcessTimeMiddleware)\n</code></pre> <p>\ud83d\udca1</p><p>Please note that you should only use the async interface for creating Middlewares, as written in the examples. The synchronous interface does not support middlewares. However, add_middleware is called synchronously, as in the example above.</p>"},{"location":"0.8.0/Middlewares/#testingmiddleware","title":"TestingMiddleware","text":"<p>Imagine you want to easily switch to test mode in your application, which means:</p> <ul> <li>You want to always send it to different subjects (the same subject, but with a <code>test</code> prefix)</li> <li>You want to remove some meaningful data from requests &amp; responses</li> </ul> <pre><code>from panini.middleware import Middleware\n\nclass TestingMiddleware(Middleware):\n    def __init__(self, meaningful_key):\n        self.meaningful_key = meaningful_key\n\n    async def send_any(self, subject: str, message, send_func, *args, **kwargs):\n                subject = \"test.\" + subject\n        if self.meaningful_key in message:\n            del message[self.meaningful_key]\n\n        response = await send_func(subject, message, *args, **kwargs)\n\n        if self.meaningful_key in response:\n            del response[self.meaningful_key]\n        return response\n\n    async def listen_any(self, msg, callback):\n        if self.meaningful_key in msg.data:\n            del msg.data[self.meaningful_key]\n\n        response = await callback(msg)\n\n        if self.meaningful_key in response:\n            del response[self.meaningful_key]\n        return response\n</code></pre> <p>Then, add the TestingMiddleware to your application and specify the <code>meaningful_key</code> parameter like this:</p> <pre><code>app.add_middleware(TestingMiddleware, \"meaningful_key\")\n</code></pre> <p>\ud83d\udca1</p><p>Please note that you should only use the async interface for creating Middlewares, as written in the examples. The synchronous interface does not support middleware. However, add_middleware is called synchronously, as in the example above.</p>"},{"location":"0.8.0/Middlewares/#built-in-middlewares","title":"Built-in Middlewares","text":"<p>You can use some built-in middlewares for common cases that are already implemented in Panini:</p> <ul> <li><code>ErrorMiddleware</code> - calls the callback when an error occurs</li> <li><code>NATSTimeoutMiddleware</code> - logs the NATS timeout</li> <li><code>PrometheusMonitoringMiddleware</code> - measures the performance of the app; for more details, see here</li> </ul>"},{"location":"0.8.0/Middlewares/#hierarchical-middlewares","title":"Hierarchical Middlewares","text":"<p>If you want to create hierarchical middlewares with more than one inheritance, please recall the methods from your base middleware:</p> <pre><code>class FooMiddleware(Middleware):\n    async def send_publish(self, subject: str, message, publish_func, *args, **kwargs):\n        print(\"In Foo Middleware: publish\")\n        await publish_func(subject, message, *args, **kwargs)\n\nclass BarMiddleware(FooMiddleware):\n    async def send_request(self, subject: str, message, request_func, *args, **kwargs):\n        print(\"In Bar Middleware: request\")\n                return await request_func(subject, message, *args, **kwargs)\n\n    async def send_publish(self, subject: str, message, publish_func, *args, **kwargs):\n        return await super(BarMiddleware, self).send_publish(subject, message, *args, **kwargs)\n</code></pre>"},{"location":"0.8.0/Panini_App_Arguments/","title":"Panini App Arguments","text":"<p>The Panini app is available on <code>panini.app.App</code>. An example of how to use it is provided below:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n        service_name='listener_app',\n        host='127.0.0.1',\n        port=4222,\n)\n</code></pre> <p>The following parameters can be used optionaly when creating an instance of the Panini app:</p> <ul> <li>host(str): The host of the NATS broker.</li> <li>port(int): The port of the NATS broker.</li> <li>service_name(str): The name of the microservice, which will be used as part of the NATS client_id if a custom client_id is not set.</li> <li>servers(list): An alternative to the NATS broker host and port, allowing the microservice to establish a connection with multiple NATS brokers.</li> <li>client_id(str): A custom NATS client_id.</li> <li>reconnect(bool): Establishes a connection again if the connection to the NATS broker is lost.</li> <li>max_reconnect_attempts(int): The maximum number of attempts to reconnect.</li> <li>reconnecting_time_sleep(int): The pause between reconnections.</li> <li>allocation_queue_group(str): The name of the queue group. Incoming traffic is allocated between group members.</li> <li>logger_required(bool): Logger required for the project; if not, a default logger will be provided.</li> <li>logger_files_path(str): The main path for logs.</li> <li>logger_in_separate_process(bool): Use log in the same or in different process.</li> <li>pending_bytes_limit(int): The limit of bytes for a single incoming message.</li> <li>auth(dict): A dict with arguments for authentication.</li> <li>Any additional arguments from nats.py Client class.</li> </ul> <p>When creating an instance of the Panini app, make sure to provide the necessary parameters in order to ensure successful connection.</p>"},{"location":"0.8.0/Panini_App_Functions/","title":"Panini App Functions","text":""},{"location":"0.8.0/Panini_App_Functions/#decorators","title":"Decorators","text":"<p><code>@app.task()</code> - an asyncio task that is launched with the application, executed once</p> <p>Usage example:</p> <pre><code>@app.task()\nasync def publish():\n    while True:\n        message = get_some_update()\n        await app.publish(subject='some.subject', message=message)\n</code></pre> <p><code>@app.task(interval=1)</code> - same asyncio task but runs at a given interval</p> <p>Usage example:</p> <pre><code>@app.task(interval=2)\nasync def your_periodic_task():\n    for _ in range(10):\n        await app.publish(subject='some.publish.subject', message={'some':'data'})\n</code></pre> <p>Supported arguments:</p> <ul> <li>interval(int or float): waiting time between periodic task executions</li> </ul> <p><code>@app.listen(subject=\"some.subject\")</code> - subscribe to the specified subject and run a callback for every incoming message</p> <p>Usage example:</p> <pre><code>@app.listen(subject='some.subject')\nasync def subject_for_requests_listener(msg):\n    subject = msg.subject\n    message = msg.data\n    # handle incoming message\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject(str): NATS subject to subscribe</li> </ul>"},{"location":"0.8.0/Panini_App_Functions/#functions","title":"Functions","text":"<p>Parameters from all functions:</p> <ul> <li>subject(str): NATS subject to send or subscribe</li> <li>msg(): NATS single message object to receive <li>reply_to(str): An additional subject for a response, relevant if you want to request from one microservice but receive by another one</li> <li>force(bool): This flag trigger immediately sends all messages in a buffer. Otherwise, the messages are send periodically. Sending frequency depends on how many asyncio tasks are running in the loop</li> <li>data_type( or str): allows choosing a type of message body to send or receive. More details  <li>timeout(int or float): only for requests, like HTTP request timeout but for NATS requests</li> <li>ssid(str): subscription ID</li> <li>callback(CoroutineType): function to call when received a new message</li> <p>app.publish</p> <p>Usage example:</p> <pre><code>await app.publish(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported parameters:</p> <ul> <li>subject</li> <li>message</li> <li>reply_to</li> <li>force</li> </ul> <p>response - None</p> <p>app.request</p> <p>Usage example:</p> <pre><code>response = await app.request(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported parameters:</p> <ul> <li>subject</li> <li>message</li> <li>timeout</li> <li>response_data_type</li> </ul> <p>response - message body, type depends on given data_type</p> <p>app.nats.publish_from_another_thread</p> <p>Usage example:</p> <pre><code>app.nats.publish_from_another_thread(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject</li> <li>message</li> <li>reply_to</li> <li>force</li> </ul> <p>response - None</p> <p>app.request_from_another_thread</p> <p>Usage example:</p> <pre><code>response = await app.request_from_another_thread(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported parameters:</p> <ul> <li>subject</li> <li>message</li> <li>timeout</li> <li>headers</li> </ul> <p>response - message body, type depends on given data_type</p> <p>app.subscribe_new_subject</p> <p>Usage example:</p> <pre><code>await app.subscribe_new_subject(subject='some.subject', callback=some_funcion)\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject</li> <li>callback</li> </ul> <p>response - subscription ID</p> <p>app.unsubscribe_subject</p> <p>Usage example:</p> <pre><code>await app.unsubscribe_subject(subject='some.subject')\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject</li> </ul> <p>response - None</p> <p>app.unsubscribe_ssid</p> <p>Usage example:</p> <pre><code>await app.unsubscribe_ssid(ssid='some.subject')\n</code></pre> <p>Supported arguments:</p> <ul> <li>ssid</li> </ul> <p>response - None</p> <p>app.disconnect</p> <p>Usage example:</p> <pre><code>await app.disconnect()\n</code></pre> <p>app.publish_sync</p> <p>Usage example:</p> <pre><code>app.publish_syn\u0441(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported parameters:</p> <ul> <li>subject</li> <li>message</li> <li>reply_to</li> <li>force</li> </ul> <p>response - None</p> <p>app.request_sync</p> <p>Usage example:</p> <pre><code>await app.request_sync(subject='some.subject', message={'some':'message'})\n</code></pre> <p>Supported parameters:</p> <ul> <li>subject</li> <li>message</li> <li>timeout</li> <li>response_data_type</li> </ul> <p>response - message body, type depends on given response_data_type</p> <p>app.subscribe_new_subject_sync</p> <p>Usage example:</p> <pre><code>await app.subscribe_new_subject(subject='some.subject', callback=some_funcion)\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject</li> <li>callback</li> </ul> <p>response - subscription ID</p> <p>app.unsubscribe_subject_sync</p> <p>Usage example:</p> <pre><code>await app.unsubscribe_subject(subject='some.subject')\n</code></pre> <p>Supported arguments:</p> <ul> <li>subject</li> </ul> <p>response - None</p> <p>app.disconnect_sync</p> <p>Usage example:</p> <pre><code>app.disconnect_sync()\n</code></pre> <p>app.middlewares</p> <p>Usage example:</p> <pre><code>app.add_middleware(SomeMiddleware)\n</code></pre> <p>Supported arguments:</p> <ul> <li>cls(class 'Middleware')</li> </ul>"},{"location":"0.8.0/Panini_Validation/","title":"Panini Validation","text":""},{"location":"0.8.0/Panini_Validation/#how-to-validate-panini-microservice-is-connected","title":"How to validate panini microservice is connected","text":"<ol> <li>Make sure that NATS server is running, how to run it  <li>Create a simple app that periodically sends a message by one asyncio task and receives the message by another task. The whole app is a single module  <code>app.py</code>:</li> <pre><code>from panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='quickstart-app',\n        host='127.0.0.1',\n        port=4222,\n)\n\n@app.task(interval=1)\nasync def publish_periodically():\n        await app.publish(subject=\"some.publish.subject\", message={'some_key':'Hello stream world'})\n\n@app.listen(\"some.request.subject\")\nasync def receive_messages(msg):\n    subject = msg.subject\n    message = msg.data\n        print('Yai! I got new message from stream: {subject}:{message}')\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <ol> <li>Run app.py:</li> </ol> <pre><code>&gt; python3 app.py\n======================================================================================\nPanini service connected to NATS..\nid: 2\nname: quickstart-app__non_docker_env_98846__896705\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n\nYai! I got new message from stream: {subject}:{message}\nYai! I got new message from stream: {subject}:{message}\nYai! I got new message from stream: {subject}:{message}\nYai! I got new message from stream: {subject}:{message}\n</code></pre> <p>Check panini app as a client of NATS broker:</p> <pre><code>curl http://127.0.0.1:8222/connz\n</code></pre> <p>You should get something like:</p> <pre><code>{\n  \"server_id\": \"NAKBPTP3AFN3XG4CJBMARGTJPWQS6M6DH2OZ4S5F6MAV4DXEJKXNIVC6\",\n  \"now\": \"2021-05-02T22:36:11.940857451Z\",\n  \"num_connections\": 1,\n  \"total\": 1,\n  \"offset\": 0,\n  \"limit\": 1024,\n  \"connections\": [\n    {\n      \"cid\": 2,\n      \"ip\": \"192.168.240.21\",\n      \"port\": 35454,\n      \"start\": \"2021-04-27T18:05:31.848989012Z\",\n      \"last_activity\": \"2021-05-02T22:36:11.882566724Z\",\n      \"rtt\": \"214\u00b5s\",\n      \"uptime\": \"5d4h30m40s\",\n      \"idle\": \"0s\",\n      \"pending_bytes\": 0,\n      \"in_msgs\": 4,\n      \"out_msgs\": 4,\n      \"in_bytes\": 345,\n      \"out_bytes\": 345,\n      \"subscriptions\": 1,\n      \"name\": \"quickstart-app__non_docker_env_98846__896705\",\n      \"lang\": \"python3\",\n      \"version\": \"0.9.2\"\n    }\n</code></pre> <p>All your microservices under field <code>connections</code></p>"},{"location":"0.8.0/Panini_Validation/#_1","title":"Panini Validation","text":"<p>Improved text:</p>"},{"location":"0.8.0/Panini_Validation/#how-to-validate-panini-microservice-is-connected_1","title":"How to Validate Panini Microservice is Connected","text":"<p>To make sure that your Panini microservice is connected to the NATS server, follow these steps:</p> <ol> <li>Ensure that the NATS server is running. If you need instructions on how to do this, refer to . <li>Create a simple app to periodically send a message by one asyncio task, and receive the message by another task. This should be a single module named <code>app.py</code>, containing the following code:</li> <pre><code>from panini import  app as panini_app\n\napp = panini_app.App(\n        service_name='quickstart-app',\n        host='127.0.0.1',\n        port=4222,\n)\n\n@app.task(interval=1)\nasync def publish_periodically():\n        await app.publish(subject=\"some.publish.subject\", message={'some_key':'Hello stream world'})\n\n@app.listen(\"some.request.subject\")\nasync def receive_messages(msg):\n    subject = msg.subject\n    message = msg.data\n        print('Yai! I got new message from stream: {subject}:{message}')\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <ol> <li>Run app.py:</li> </ol> <pre><code>&gt; python3 app.py\n</code></pre> <p>This should give you an output like:</p> <pre><code>======================================================================================\nPanini service connected to NATS..\nid: 2\nname: quickstart-app__non_docker_env_98846__896705\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n\nYai! I got new message from stream: {subject}:{message}\nYai! I got new message from stream: {subject}:{message}\nYai! I got new message from stream: {subject}:{message}\nYai! I got new message from stream: {subject}:{message}\n</code></pre> <p>To check if the Panini app is connected to the NATS broker, run the following command in your terminal:</p> <pre><code>curl http://127.0.0.1:8222/connz\n</code></pre> <p>You should get an output like this:</p> <pre><code>{\n  \"server_id\": \"NAKBPTP3AFN3XG4CJBMARGTJPWQS6M6DH2OZ4S5F6MAV4DXEJKXNIVC6\",\n  \"now\": \"2021-05-02T22:36:11.940857451Z\",\n  \"num_connections\": 1,\n  \"total\": 1,\n  \"offset\": 0,\n  \"limit\": 1024,\n  \"connections\": [\n    {\n      \"cid\": 2,\n      \"ip\": \"192.168.240.21\",\n      \"port\": 35454,\n      \"start\": \"2021-04-27T18:05:31.848989012Z\",\n      \"last_activity\": \"2021-05-02T22:36:11.882566724Z\",\n      \"rtt\": \"214\u00b5s\",\n      \"uptime\": \"5d4h30m40s\",\n      \"idle\": \"0s\",\n      \"pending_bytes\": 0,\n      \"in_msgs\": 4,\n      \"out_msgs\": 4,\n      \"in_bytes\": 345,\n      \"out_bytes\": 345,\n      \"subscriptions\": 1,\n      \"name\": \"quickstart-app__non_docker_env_98846__896705\",\n      \"lang\": \"python3\",\n      \"version\": \"0.9.2\"\n    }\n</code></pre> <p>All your microservices should be listed under the <code>connections</code> field.</p>"},{"location":"0.8.0/Quickstart/","title":"Introduction to Panini","text":"<p>Panini is a modern framework for fast and straightforward microservice development. It's a Flask-like solution, but for NATS messaging. </p> <p>To get started with Panini, you should have a minimal experience with Python, and have a basic understanding of NATS, FastAPI, Aiohttp, or Flask.</p>"},{"location":"0.8.0/Quickstart/#a-simple-listener-app-example","title":"A simple listener app example","text":"<p>A minimal app with one stream endpoint, one request endpoint, and one periodic task might look like this:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n        service_name='listener_app',\n        host='127.0.0.1',\n        port=4222,\n)\n\n@app.listen(\"some.subject.for.request\")\nasync def request_listener(msg):\n\"\"\" request endpoint \"\"\"\n    print(f\"request {msg.data} from {msg.subject} has been processed\")\n    return {\"success\": True, \"message\": \"request has been processed\"}\n\n@app.listen(\"some.subject.for.stream\")\nasync def stream_listener(msg):\n\"\"\" stream endpoint \"\"\"\n    print(f\"event {msg.data} from {msg.subject} has been processed\")\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>What's going on here?</p> <ol> <li>We imported Panini.</li> <li>We initialized the app. We created an instance of the class <code>App</code> from the module <code>panini</code> with a microservice name, NATS host, and port.</li> <li>The first <code>@app.listen</code> registers the listening subject <code>\"some.subject.for.request\"</code> with the function <code>request_listener</code>. Every time this app receives a request addressed to <code>\"some.subject.for.request\"</code>, the function <code>request_listener</code> is called to process it, then it sends a return response back to the addressee.</li> <li>The second <code>@app.listen</code> registers the listening subject <code>\"some.subject.for.stream\"</code> with the function <code>stream_listener</code>. This works the same way as with <code>request_listener</code> but without sending the result back.</li> <li>The <code>app.start()</code> runs the app. No code under this command will ever be called.</li> </ol> <p>Save the above code to file listener_app.py.</p> <p>\ud83d\udca1</p><p> The current function expects only JSON formattable returns, dict or list. However, you can also specify it as string or bytes. More details about this in the Datatypes section.</p> <p>Make sure that you have all prerequisites from the Install guide. Open the terminal to run the app:</p> <pre><code>&gt; python3 listener_app.py\n======================================================================================\nPanini service connected to NATS..\nid: 3\nname: listener_app__non_docker_env_270377__75017\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n</code></pre> <p>That's it. Now let's create something that will generate messages.</p>"},{"location":"0.8.0/Quickstart/#a-simple-app-example-that-generates-messages","title":"A simple app example that generates messages","text":"<p>Our goal here is to trigger endpoints from the listener app above: </p> <ul> <li>\"some.subject.for.request\"  - request something, receive response</li> <li>\"some.subject.for.stream\" - send some event without waiting for response</li> </ul> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n        service_name='sender_app',\n        host='127.0.0.1',\n        port=4222,\n)\n\n@app.task(interval=1)\nasync def request_periodically():\n        message = {\"data\":\"request1234567890\"}\n    response = await app.request(\n        subject=\"some.subject.for.request\", \n        message=message,\n    )\n    print(response)\n\n\n@app.task(interval=1)\nasync def publish_periodically():\n    message = {\"data\":\"event1234567890\"}\n    await app.publish(\n        subject=\"some.subject.for.stream\", \n        message=message,\n    )\n\nif __name__ == \"__main__\":\n    app.start()\n</code></pre> <p>What's new here:</p> <ol> <li>First, <code>@app.task</code> registers a function <code>request_periodically</code> to call it periodically at given interval, each 1 second in the example.</li> <li>Function <code>app.request</code> sends requests, asynchronously waits for a response.</li> <li>The second <code>@app.task</code> does the same as the first one but for publishing.</li> <li>Function <code>app.publish</code> sends a message like a request but without expecting any response. Fire and forget.</li> </ol> <p>Save the code to a new file sender_app.py.</p> <p>Make sure that listener_app.py keeps running, then open a new terminal session to run the sender app:</p> <pre><code>&gt; python3 sender_app.py\n======================================================================================\nPanini service connected to NATS..\nid: 3\nname: sender_app__non_docker_env_270377__75017\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n{'success': True, 'message': 'request has been processed'}\n</code></pre> <p>Note that in the terminal session where you run listener_app.py you should see received requests and events:</p> <pre><code>event {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\nevent {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\nevent {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\nevent {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\nevent {'data': 'event1234567890'} from some.subject.for.stream has been processed\nrequest {'data': 'request1234567890'} from some.subject.for.request has been processed\n</code></pre>"},{"location":"0.8.0/Quickstart/#more-possibilities","title":"More possibilities","text":"<p>In the first example, we created an application that listens for messages, in the second example, an application that sends messages. Panini allows you to freely combine sending and receiving messages in one application. </p> <p>Let's check out what else you can do with Panini using a minimal interface:</p> <ul> <li>One-time tasks on start. Similar to the above periodic task but without <code>interval</code> argument</li> </ul> <pre><code>@app.task()\nasync def publish():\n    while True:\n        message = get_some_update()\n        await app.publish(subject='some.subject', message=message)\n</code></pre> <ul> <li>Synchronous endpoints</li> </ul> <pre><code>@app.task(interval=2)\ndef your_periodic_task():\n    for _ in range(10):\n        app.publish_sync(\n            subject='some.publish.subject', \n            message={'some':'data'}\n        )\n</code></pre> <ul> <li>Accept different datatypes: dict, str, bytes</li> </ul> <pre><code>@app.timer_task(interval=2)\ndef your_periodic_task():\n    for _ in range(10):\n        app.publish_sync(\n            subject='some.publish.subject', \n            message=b'messageinbytestosend', \n            data_type=bytes\n        )\n</code></pre> <ul> <li>Create middlewares for NATS messages</li> </ul> <pre><code>from panini.middleware import Middleware\n\nclass MyMiddleware(Middleware):\n\n    async def send_publish(self, subject, message, publish_func, **kwargs):\n        print('do something before publish')\n        await publish_func(subject, message, **kwargs)\n        print('do something after publish')\n\n    async def listen_publish(self, msg, cb):\n        print('do something before listen')\n        await cb(msg)\n        print('do something after listen')\n\n    async def send_request(self, subject, message, request_func, **kwargs):\n        print('do something before send request')\n        result = await request_func(subject, message, **kwargs)\n        print('do something after send request')\n        return result\n\n    async def listen_request(self, msg, cb):\n        print('do something before listen request')\n        result = await cb(msg)\n        print('do something after listen request')\n        return result\n</code></pre> <ul> <li> <p>Create HTTP endpoints with Aiohttp and NATS endpoints all together in one microservice</p> <pre><code>from aiohttp import web\n\n@app.listen('some.publish.subject')\nasync def subject_for_requests_listener(msg):\n    handle_incoming_message(msg.subject, msg.data)\n\n@app.http.get('/get')\nasync def web_endpoint_listener(request):\n\"\"\"\n    Single HTTP endpoint\n    \"\"\"\n    return web.Response(text=\"Hello, world\")\n\n@app.http.view('/path/to/rest/endpoints')\nclass MyView(web.View):\n\"\"\"\n    HTTP endpoints for REST schema\n    \"\"\"\n    async def get(self):\n        request = self.request\n        return web.Response(text=\"Hello, REST world\")\n\n    async def post(self):\n        request = self.request\n        return web.Response(text=\"Hello, REST world\")\n</code></pre> </li> </ul> <p>It is possible to create middlewares for NATS messages using Panini. The process is quite simple and can be done by creating a class that extends the <code>Middleware</code> class and adding the necessary functions like <code>send_publish</code>, <code>listen_publish</code>, <code>send_request</code>, and <code>listen_request</code>. Once you have the middleware setup, you can also create HTTP endpoints with Aiohttp and NATS endpoints all together in one microservice. You can do this by using the <code>app.listen</code> and <code>app.http</code> methods. </p> <ul> <li>Built-in traffic balancing between instances of the microservice if you have high loads</li> </ul> <pre><code>app = panini_app.App(\n        service_name='async_publish',\n        host='127.0.0.1',\n        allocation_queue_group='group24', \n        port=4222,\n)\n\n# incoming traffic will be distributed among \n# all microservices that are in the \"group24\"\n</code></pre> <p>If you have high loads, you can use Panini's built-in traffic balancing capabilities by specifying the <code>allocation_queue_group</code> parameter when creating your <code>App</code> instance. This will make sure that the incoming traffic is distributed among all microservices that are in the group you specified. For more examples of how to use Panini, you can check out this page.</p>"},{"location":"0.8.0/Testing/","title":"Testing","text":"<p>Panini testing is possible with various testing frameworks.  Here we will show testing based on pytest framework.</p>"},{"location":"0.8.0/Testing/#using-testclient","title":"Using TestClient","text":"<p>Import <code>TestClient</code>.</p> <p>Create a <code>TestClient</code> using pytest.fixture by passing it to the function that runs panini.</p> <p>TestClient object <code>.start()</code> will start the panini app for testing.</p> <p>Create <code>functions</code> with a name that starts with <code>test_</code> (this is standard <code>pytest</code> convention).</p> <p>Use the <code>TestClient</code> object for NATS communication the same way you would do with <code>panini</code> </p> <p>Panini uses nats-python synchronous NATS client for testing</p> <p>Write simple <code>assert</code> statements with the standard Python expressions that you need to check (<code>pytest</code> standard).</p> <pre><code>import pytest\nfrom panini import app as panini_app\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    app = panini_app.App(\n        service_name=\"test\",\n        host=\"127.0.0.1\",\n        port=4222\n    )\n\n    @app.listen(\"main.subject\")\n    def main_subject(msg):\n        return {\"message\": \"Hello World!\"}\n\n    app.start()\n\n@pytest.fixture\ndef client():\n    client = TestClient(run_panini).start()\n    yield client\n    client.stop()\n\ndef test_main_subject(client):\n    response = client.request(\"main.subject\", {})\n    assert response[\"message\"] == \"Hello World!\"\n</code></pre> <p>\ud83d\udd25</p><p> Notice that the testing functions are normal def, not async def. Also, the calls to the client are also normal calls, not using await. This allows you to use pytest directly without complications.</p> <p>\ud83d\udee0</p><p> Notice that panini TestClient will run a panini app in a  different process.  The Windows and Mac platforms have limitations for transferring objects to a different process. So we have to use  run_panini function that will implement or import our app, and we must use  fixtures to setup TestClient.</p> <p>\ud83d\udd11</p><p>  Notice that if you use pytest.fixture without scope the panini App will setup and teardown for each test. If you don't want this - please use pytest.fixture(scope=\"module)</p>"},{"location":"0.8.0/Testing/#separating-tests","title":"Separating tests","text":"<p>In a real application, you mostly would have your tests in a different file.</p> <p>Your Panini app can also be in different files or modules.</p>"},{"location":"0.8.0/Testing/#panini-app-file","title":"Panini app file","text":"<p>Let's say you have a file <code>main.py</code> with your Panini app:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.listen(\"main.subject\")\ndef main_subject(msg):\n    return {\"message\": \"Hello World!\"}\n\nif __name__ == '__main__':\n    app.start()\n</code></pre>"},{"location":"0.8.0/Testing/#testing-file","title":"Testing file","text":"<p>Then you could have a file <code>test_main.py</code> with your tests, and import your app from the <code>main</code> module (<code>main.py</code>):</p> <pre><code>import pytest\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    from .main import app\n    app.start()\n\n@pytest.fixture\ndef client():\n    client = TestClient(run_panini).start()\n    yield client\n    client.stop()\n\ndef test_main_subject(client):\n    response = client.request(\"main.subject\", {})\n    assert response[\"message\"] == \"Hello World!\"\n</code></pre>"},{"location":"0.8.0/Testing/#advanced-testing","title":"Advanced testing","text":"<p>Now, let's dig into more details to see how to test different parts.</p> <p>\u2699</p><p> Under the hood, TestClient will run your panini application inside the different process. And will communicate with it only using NATS messaging. This is how you can simulate your panini app activity.</p> <p>\ud83d\udee0</p><p>TestClient will run 2 NATS clients for testing (one for sending, and one for listening). The sending NATS client is in the main Thread, while the listening client can be in a separate thread.</p>"},{"location":"0.8.0/Testing/#error-testing","title":"Error testing","text":"<p>Let's say we need to check that the subject always requires an authorization.</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.listen(\"subject.with.authorization\")\ndef get_secret(msg):\n    if \"authorization\" not in msg.data:\n        raise ValueError(\"You need to be authorized, to get the secret data!\")\n    return {\"secret\": \"some meaningful data\"}\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p>Let's create a test for this example</p> <pre><code>import pytest\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\n@pytest.fixture(scope=\"module\")\ndef client():\n    client = TestClient(run_panini).start()\n    yield client\n    client.stop()\n\ndef test_secret_subject(client):\n    response = client.request(\"subject.with.authorization\", {\"authorization\": \"token\"})\n    assert response[\"secret\"] == \"some meaningful data\"\n\ndef test_unauthorized_secret_subject(client):\n    with pytest.raises(OSError):\n        client.request(\"subject.with.authorization\", {})\n</code></pre> <p>We can use this method of testing, but if we take a better look - it's strange that we are getting a <code>OSError</code> instead of a <code>ValueError</code> Also, the tests will run for an extremely long time because of nats-timeout.</p> <p>The reason for this is that <code>TestClient</code> is a separate NATS service, that performs a simple request in our case. It does not get the response, because of an error on the application side.</p> <p>But still, let's modify a bit our functions, to get the more obvious result:</p> <pre><code>@app.listen(\"subject.with.authorization\")\ndef get_secret(msg):\n    if \"authorization\" not in msg.data:\n        return {\"success\": False, \"message\": \"You have to be authorized, to get the secret data!\"}\n    return {\"success\": True, \"secret\": \"some meaningful data\"}\n</code></pre> <p>And the test function will look like this:</p> <pre><code>def test_unauthorized_secret_subject(client):\n    response = client.request(\"subject.with.authorization\", {})\n    assert response[\"success\"] is False\n    assert response[\"message\"] == \"You have to be authorized, to get the secret data!\"\n</code></pre> <p>So we get the results faster and in a more obvious way.</p>"},{"location":"0.8.0/Testing/#testing-microservice-with-dependencies","title":"Testing microservice with dependencies","text":"<p>Let's say we want to test an authorization application, which depends on another panini application, that fetches data from a DB.</p> <p>For our testing purpose, we don't want to create &amp; support the database, because our application does not have a direct dependency on DB.</p> <p>Using <code>TestClient</code> we can <code>mock</code> the communication between those applications. </p> <p>Let's dive into the code:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"authorization_microservice\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.listen(\"get.token\")\nasync def get_token(msg):\n    if \"email\" not in msg.data or \"password\" not in msg.data:\n        return {\"message\": \"You should provide email &amp; password to authorize\"}\n    response = await app.request(\"db.authorization\", {\"email\": msg.data[\"email\"], \"password\": msg.data[\"password\"]})\n    return {\"token\": response[\"db_token\"]}\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p>And then, apply <code>mocking</code> using <code>TestClient</code> object <code>.listen</code> function.</p> <pre><code>import pytest\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\nfake_db = {\"test_email\": \"test_token\"}\n\n@pytest.fixture()\ndef client():\n    client = TestClient(run_panini)\n\n    @client.listen(\"db.authorization\")  # mock db.authorization subject\n    def authorize(msg):\n        return {\"db_token\": fake_db[msg.data[\"email\"]]}  # provide testing data\n\n    client.start()\n    yield client\n    client.stop()\n\ndef test_get_token(client):\n    response = client.request(\"get.token\", {\"email\": \"test_email\", \"password\": \"test_password\"})\n    assert response[\"token\"] == \"test_token\"\n</code></pre> <p>\ud83d\udca1</p><p>Notice that you have to call @client.listen decorator before client.start()</p>"},{"location":"0.8.0/Testing/#testclient-publish-wait","title":"TestClient publish &amp; wait","text":"<p>We strongly recommend using other tools for testing (like <code>client.request</code> &amp; <code>client.listen</code> only), but sometimes we need a specific <code>client.publish</code> &amp; <code>client.wait</code> to test the panini application.</p> <p>\ud83d\udcd6</p><p>client.wait is used to manually wait for @client.listen callback to be called. It was previously done automatically</p> <p>\u261d</p><p>You should specify client.start(do_always_listen=False) to be able to use client.wait</p> <p>Example for <code>client.publish</code> &amp; <code>client.wait</code>:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.listen(\"start\")\nasync def start(msg):\n    await app.publish(\"app.started\", {\"success\": True})\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p>And testing file:</p> <pre><code>import pytest\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\nis_app_started = False\n\n@pytest.fixture()\ndef client():\n    client = TestClient(run_panini)\n\n    @client.listen(\"app.started\")\n    def app_started(msg):\n        global is_app_started\n        is_app_started = True\n\n    client.start(do_always_listen=False)\n    yield client\n    client.stop()\n\ndef test_get_token(client):\n    assert is_app_started is False\n    client.publish(\"start\", {})\n    client.wait(1)  # wait for @client.listen callback to work\n    assert is_app_started is True\n</code></pre> <p>\ud83d\udca1</p><p>Use client.publish only, when @client.listen returns nothing or subject. But you will need another subject, to check, if the call was successful.</p> <p>Example for <code>client.wait</code>:</p> <p>Let's say you want to test <code>@app.task</code> job:</p> <pre><code>from panini import app as panini_app\n\napp = panini_app.App(\n    service_name=\"test\",\n    host=\"127.0.0.1\",\n    port=4222\n)\n\n@app.task()\nasync def task():\n    await app.publish(\"task.job\", {\"job\": \"test\"})\n\nif __name__ == '__main__':\n    app.start()\n</code></pre> <p>You can use <code>@client.listen</code> and <code>client.wait</code> for this:</p> <pre><code>import pytest\nfrom panini.test_client import TestClient\n\ndef run_panini():\n    from main import app\n    app.start()\n\ntask_data = None\n\n@pytest.fixture()\ndef client():\n    client = TestClient(run_panini)\n\n    @client.listen(\"task.job\")\n    def app_started(msg):\n        global task_data\n        task_data = msg.data[\"job\"]\n\n    client.start(do_always_listen=False)\n    yield client\n    client.stop()\n\ndef test_get_token(client):\n    assert task_data is None\n    client.wait(1)  # wait for @client.listen callback to work\n    assert task_data == \"test\"\n</code></pre>"},{"location":"0.8.0/WebSocket_server/","title":"WebSocket server","text":"<p>Panini also uses Aiohttp for WebSockets. Let's see how it works using the example below.</p> <p>Suppose we want to create a microservice - a gateway between NATS stream and WebSockets stream. It subscribes to the desired NATS subject from a frontend and broadcasts them to a frontend in \"live mode\". To implement this we need:</p> <ul> <li>Web interface with web socket connection</li> <li>GET endpoint to upload interface</li> <li>POST endpoint to subscribe/unsubscribe to NATS subjects</li> <li>WSS endpoint to receive live messages</li> <li>Some NATS message producer to test microservice</li> <li>Main logic that handles subscribe/unsubscribe requests</li> </ul> <p>Let's split the app into two modules. One for the main app - <code>main.py</code> and another for subscribe/unsubscribe request handler &amp; web page - <code>handler.py</code> </p> <p><code>main.py</code>:</p> <pre><code>import uuid\nimport random\nimport json\nfrom aiohttp import web\nfrom panini import app as panini_app\nfrom handler import WSSManager, html\n\napp = panini_app.App(\n    service_name=\"async_NATS_WSS_bridge\",\n    host='127.0.0.1',\n    port=4222,\n)\napp.setup_web_server(port=5001)\nlogger = app.logger\n\nasync def incoming_messages_callback(subscriber, msg, **kwargs):\n\"\"\"\n        app calls it for each new message from\n        NATS and redirects the message\n        \"\"\"\n    try:\n        await subscriber.send_str(\n            json.dumps({\"subject\": msg.subject, \"data\": msg.data})\n        )\n    except Exception as e:\n        logger.error(f\"error: {str(e)}\")\n\nmanager = WSSManager(app)\nmanager.callback = incoming_messages_callback\n\ntest_msg = {\n    \"key1\": \"value1\",\n    \"key2\": 2,\n    \"key3\": 3.0,\n    \"key4\": [1, 2, 3, 4],\n    \"key5\": {\"1\": 1, \"2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key6\": {\"subkey1\": \"1\", \"subkey2\": 2, \"3\": 3, \"4\": 4, \"5\": 5},\n    \"key7\": None,\n}\n\n@app.task(interval=1)\nasync def publish_periodically_for_test():\n    test_msg[\"key3\"] = random.random()\n    await app.publish(\"test.subject\", test_msg)\n\n@app.http.get(\"/\")\nasync def web_endpoint_listener(request):\n\"\"\"\n    Web client to view NATS stream. Displays messages from subjects that an user is following\n\n    Example of request\n    subscribe:\n    {\"subjects\":[\"*.&gt;\"],\"action\":\"subscribe\"}\n    unsubscribe:\n    {\"subjects\":[\"*.&gt;\"],\"action\":\"unsubscribe\"}\n\n    \"\"\"\n    return web.Response(text=html, content_type=\"text/html\")\n\n@app.http.get(\"/stream\")\nasync def web_endpoint_listener(request):\n\"\"\"WebSocket connection \"\"\"\n    ws = web.WebSocketResponse()\n    await ws.prepare(request)\n    connection_id = str(uuid.uuid4())[:10]\n    await ws.send_str(json.dumps({\"success\": True, \"data\": \"Successfully connected\"}))\n    await manager.client_listener(ws, connection_id)\n    try:\n        await ws.close()\n    except Exception as e:\n        logger.error(str(e))\n    return ws\n\nasync def incoming_messages_callback(subscriber, msg, **kwargs):\n\"\"\"\n        app calls it for each new message from\n        NATS and redirects the message\n        \"\"\"\n    try:\n        await subscriber.send_str(\n            json.dumps({\"subject\": msg.subject, \"data\": msg.data})\n        )\n    except Exception as e:\n        logger.error(f\"error: {str(e)}\")\n\nif __name__ == \"__main__\":\n    app.http_server.web_app[\"subscribers\"] = {}\n    app.start()\n</code></pre> <ol> <li><code>from handler import WSSManager, html</code> imports from another module, handler.py</li> <li><code>manager = WSSManager(app)</code>  initializing of class that handles subscription/unsubscription requests from the users of the frontend</li> <li><code>manager.callback = incoming_messages_callback</code>  setting callback to incoming NATS messages</li> <li><code>test_msg</code>  - message for NATS stream</li> <li><code>@app.task(interval=1)</code>  - function under the decorator publishes messages periodically to subject \"test.subject\"</li> <li><code>@app.http.get(\"/\")</code>  - function under the decorator received HTTP request to get main web page</li> <li><code>@app.http.get(\"/stream\")</code>  - function under the decorator received HTTP request to subscribe user to NATS subject</li> <li><code>app.http_server.web_app[\"subscribers\"] = {}</code>  - This is where we store subscribers</li> </ol> <p>Let's take a look at handler.py. It includes web page and WebSocket handler</p> <p><code>handler.py</code>: <pre><code>import json\nimport copy\nfrom panini.utils.logger import get_logger\nfrom aiohttp.http_websocket import WSMsgType\n\nlogger = get_logger(None)\n\nhtml = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;NATS Bridge&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;WebSocket&lt;/h1&gt;\n        &lt;form action=\"\" onsubmit=\"sendMessage(event)\"&gt;\n            &lt;input type=\"text\" id=\"messageText\" autocomplete=\"off\"/&gt;\n            &lt;button&gt;Send&lt;/button&gt;\n        &lt;/form&gt;\n        &lt;ul id='messages'&gt;\n        &lt;/ul&gt;\n        &lt;script&gt;\n            var ws = new WebSocket(`ws://${window.location.hostname}:5001/stream`);\n            ws.onmessage = function(event) {\n                var messages = document.getElementById('messages')\n                var message = document.createElement('li')\n                var content = document.createTextNode(event.data)\n                message.appendChild(content)\n                messages.appendChild(message)\n            };\n            function sendMessage(event) {\n                var input = document.getElementById(\"messageText\")\n                ws.send(input.value)\n                input.value = ''\n                event.preventDefault()\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nclass WSSManager:\n    ssid_map = {}\n\n    def __init__(self, app):\n        self.app = app\n\n    async def client_listener(self, client_ws_connection, connection_id):\n\"\"\"app calls it for each WSS message from user\"\"\"\n        while True:\n            try:\n                msg = await client_ws_connection.receive()\n                if self.is_close_connection_message(msg):\n                    await self.close_ws_client(client_ws_connection, connection_id)\n                    return client_ws_connection\n                body = json.loads(msg.data)\n                action = self.get_action(body)\n                await self.validate_ws_message(client_ws_connection, body, action)\n                subjects = body[\"subjects\"]\n                if action == \"subscribe\":\n                    for subject in subjects:\n                        cb = await self.get_callback(client_ws_connection)\n                        await self.subscribe(subject, cb)\n                    await self.send_to_ws(\n                        client_ws_connection,\n                        success=True,\n                        message=f\"Successfully connected to events: {str(subjects)[1:-1]}\"\n                    )\n                elif action == \"unsubscribe\":\n                    for subject in subjects:\n                        await self.unsubscribe(client_ws_connection, subject)\n            except Exception as e:\n                logger.error(f\"WSS error: {str(e)} connection_id {connection_id}\")\n                try:\n                    await self.send_to_ws(\n                        client_ws_connection,\n                        success=False,\n                        message=str(e)\n                    )\n                except Exception as e:\n                    logger.error(str(e), level=\"error\")\n                return client_ws_connection\n\n    async def validate_ws_message(self, client_ws_connection, body, action):\n        if action not in [\"subscribe\", \"unsubscribe\"]:\n            message = f\"The user has to specify action in message ('subscribe' or 'unsubscribe'), got {action} instead\"\n            await self.send_to_ws(\n                client_ws_connection,\n                success=False,\n                message=message\n            )\n            raise Exception(message)\n        if \"subjects\" not in body:\n            raise Exception(\"subjects required\")\n\n    def is_close_connection_message(self, msg):\n        if msg.type == WSMsgType.CLOSE and msg.data in range(1000,1003):\n            return True\n\n    async def close_ws_client(self, client_ws_connection, conn_id):\n        connections = copy.copy(self.ssid_map)\n        for subject in connections:\n            if conn_id in self.ssid_map[subject]:\n                try:\n                    del self.ssid_map[subject][conn_id]\n                    if self.ssid_map[subject] == {}:\n                        await self.app.unsubscribe_subject(subject)\n                        del self.ssid_map[subject]\n                except Exception as e:\n                    logger.error(str(e))\n        await client_ws_connection.close()\n\n    def get_action(self, body):\n        return body[\"action\"] if \"action\" in body else \"subscribe\"\n\n    async def send_to_ws(self, client_ws_connection, success: bool, message: str):\n        message = json.dumps({\n            'success': success,\n            'message': message,\n        })\n        await client_ws_connection.send_str(message)\n\n    async def subscribe(self, subject, cb):\n        ssid = await self.app.subscribe_new_subject(subject, cb)\n        if subject not in self.ssid_map:\n            self.ssid_map[subject] = []\n        self.ssid_map[subject].append(ssid)\n\n    async def unsubscribe(self, client_ws_connection, subject):\n        if not subject in self.ssid_map:\n            await self.send_to_ws(\n                client_ws_connection,\n                success=False,\n                message=f\"The user did not subscribe to event {subject}\"\n            )\n            return\n        for ssid in self.ssid_map[subject]:\n            await self.app.unsubscribe_ssid(ssid)\n        await self.send_to_ws(\n            client_ws_connection,\n            success=True,\n            message=f\"Successfully unsubscribed from event: {subject}\"\n        )\n\n    async def get_callback(self, subscriber):\n            if hasattr(self, \"callback\"):\n                cb = self.callback\n            else:\n                raise Exception(\"self.callback function for incoming messages expected\")\n\n            async def wrapper(msg):\n                return await cb(subscriber, msg)\n            return wrapper\n</code></pre> <ol> <li><code>html</code> - web page html/js code</li> <li><code>WSSManager</code> - manage every WebSocket request with NATS subject</li> </ol> <p>That's it! Let's run our main.py and check http://127.0.0.1:5001:</p> <pre><code>&gt; python3 main.p\n======================================================================================\nPanini service connected to NATS..\nid: 5\nname: async_NATS_WSS_bridge__non_docker_env_486358__955463\n\nNATS brokers:\n*  nats://127.0.0.1:4222\n======================================================================================\n\n======== Running on http://0.0.0.0:5001 ========\n</code></pre> <p>Then you need to follow the link http://0.0.0.0:5001 . If everything is correct you will get this page:</p> <p></p> <p>In order to subscribe to NATS subject \"test.subject\" you need to send a request in expected format:</p> <p>{\"subjects\":[\"test.subject\"],\"action\":\"subscribe\"}</p> <p>If everything is correct you should see NATS message on the web page:</p> <p></p> <p>You can also check this app below in our example here.</p>"},{"location":"0.8.0/What_is_NATS/","title":"What is NATS","text":"<p>The text below is mostly taken from the official NATS docs NATS is a high-performance messaging system written in Golang. NATS is very easy to use, has very high bandwidth, and easily scales. It has 48 well-known clients, 11 of which are supported by the maintainers. NATS offers delivery guarantees, high availability, and fault tolerance. NATS is used on the web, IoT, and blockchain.</p>"},{"location":"0.8.0/What_is_NATS/#subject","title":"Subject","text":"<p>Subject in NATS is like a topic for Kafka or URL for HTTP. At its simplest, a subject is just a string of characters that form a name that publishers and subscribers can use to find each other.</p>"},{"location":"0.8.0/What_is_NATS/#subject-hierarchies","title":"Subject Hierarchies","text":"<p>For example, a world clock application might define the following to logically group related subjects:</p> <pre><code>time.us\ntime.us.east\ntime.us.east.atlanta\ntime.eu.east\ntime.eu.warsaw\n</code></pre>"},{"location":"0.8.0/What_is_NATS/#wildcards","title":"Wildcards","text":"<p>NATS provides two\u00a0wildcards\u00a0that can take the place of one or more elements in a dot-separated subject. Subscribers can use these wildcards to listen to multiple subjects with a single subscription but publishers will use a fully specified subject, without the wildcard.</p>"},{"location":"0.8.0/What_is_NATS/#matching-a-single-token","title":"Matching a single token","text":"<p>The first wildcard is\u00a0<code>*</code>\u00a0which will match a single token. For example, if an application wanted to listen for eastern time zones, they could subscribe to\u00a0<code>time.*.east</code>, which would match\u00a0<code>time.us.east</code>\u00a0and\u00a0<code>time.eu.east</code>.</p> <p></p>"},{"location":"0.8.0/What_is_NATS/#matching-multiple-tokens","title":"Matching multiple tokens","text":"<p>The second wildcard is\u00a0<code>&gt;</code>\u00a0which will match one or more tokens, and can only appear at the end of the subject. For example,\u00a0<code>time.us.&gt;</code>\u00a0will match\u00a0<code>time.us.east</code>\u00a0and\u00a0<code>time.us.east.atlanta</code>, while\u00a0<code>time.us.*</code>\u00a0would only match\u00a0<code>time.us.east</code>\u00a0since it can't match more than one token.</p> <p></p>"},{"location":"0.8.0/What_is_NATS/#monitoring-and-wire-taps","title":"Monitoring and wire taps","text":"<p>Subject to your security configuration, wildcards can be used for monitoring by creating something sometimes called a\u00a0wire tap. In the simplest case, you can create a subscriber for\u00a0<code>&gt;</code>. This application will receive all messages - again, subject to security settings - sent on your NATS cluster.</p>"},{"location":"0.8.0/What_is_NATS/#mix-wildcards","title":"Mix wildcards","text":"<p>The wildcard\u00a0<code>*</code>\u00a0can appear multiple times in the same subject. Both types can be used as well. For example,\u00a0<code>*.*.east.&gt;</code>will receive\u00a0<code>time.us.east.atlanta</code>."}]}